(function () {
	'use strict';

	// generated during release, do not modify

	const PUBLIC_VERSION = '5';

	if (typeof window !== 'undefined') {
		// @ts-expect-error
		((window.__svelte ??= {}).v ??= new Set()).add(PUBLIC_VERSION);
	}

	const EACH_ITEM_REACTIVE = 1;
	const EACH_INDEX_REACTIVE = 1 << 1;
	const EACH_ITEM_IMMUTABLE = 1 << 4;

	const PROPS_IS_IMMUTABLE = 1;
	const PROPS_IS_UPDATED = 1 << 2;
	const PROPS_IS_BINDABLE = 1 << 3;
	const PROPS_IS_LAZY_INITIAL = 1 << 4;

	const TEMPLATE_FRAGMENT = 1;
	const TEMPLATE_USE_IMPORT_NODE = 1 << 1;

	const HYDRATION_START = '[';
	/** used to indicate that an `{:else}...` block was rendered */
	const HYDRATION_START_ELSE = '[!';
	const HYDRATION_END = ']';
	const HYDRATION_ERROR = {};

	const UNINITIALIZED = Symbol();

	// Dev-time component properties
	const FILENAME = Symbol('filename');

	const NAMESPACE_HTML = 'http://www.w3.org/1999/xhtml';
	const NAMESPACE_SVG = 'http://www.w3.org/2000/svg';

	var DEV = false;

	/* This file is generated by scripts/process-messages/index.js. Do not edit! */


	/**
	 * A snippet function was passed invalid arguments. Snippets should only be instantiated via `{@render ...}`
	 * @returns {never}
	 */
	function invalid_snippet_arguments() {
		{
			throw new Error(`https://svelte.dev/e/invalid_snippet_arguments`);
		}
	}

	/**
	 * `%name%(...)` can only be used during component initialisation
	 * @param {string} name
	 * @returns {never}
	 */
	function lifecycle_outside_component(name) {
		{
			throw new Error(`https://svelte.dev/e/lifecycle_outside_component`);
		}
	}

	/**
	 * Attempted to render a snippet without a `{@render}` block. This would cause the snippet code to be stringified instead of its content being rendered to the DOM. To fix this, change `{snippet}` to `{@render snippet()}`.
	 * @returns {never}
	 */
	function snippet_without_render_tag() {
		{
			throw new Error(`https://svelte.dev/e/snippet_without_render_tag`);
		}
	}

	/**
	 * The `this` prop on `<svelte:element>` must be a string, if defined
	 * @returns {never}
	 */
	function svelte_element_invalid_this_value() {
		{
			throw new Error(`https://svelte.dev/e/svelte_element_invalid_this_value`);
		}
	}

	// Store the references to globals in case someone tries to monkey patch these, causing the below
	// to de-opt (this occurs often when using popular extensions).
	var is_array = Array.isArray;
	var index_of = Array.prototype.indexOf;
	var array_from = Array.from;
	var object_keys = Object.keys;
	var define_property = Object.defineProperty;
	var get_descriptor = Object.getOwnPropertyDescriptor;
	var get_descriptors = Object.getOwnPropertyDescriptors;
	var object_prototype = Object.prototype;
	var array_prototype = Array.prototype;
	var get_prototype_of = Object.getPrototypeOf;
	var is_extensible = Object.isExtensible;

	/**
	 * @param {any} thing
	 * @returns {thing is Function}
	 */
	function is_function(thing) {
		return typeof thing === 'function';
	}

	const noop = () => {};

	// Adapted from https://github.com/then/is-promise/blob/master/index.js
	// Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE

	/**
	 * @template [T=any]
	 * @param {any} value
	 * @returns {value is PromiseLike<T>}
	 */
	function is_promise(value) {
		return typeof value?.then === 'function';
	}

	/** @param {Array<() => void>} arr */
	function run_all(arr) {
		for (var i = 0; i < arr.length; i++) {
			arr[i]();
		}
	}

	const DERIVED = 1 << 1;
	const EFFECT = 1 << 2;
	const RENDER_EFFECT = 1 << 3;
	const BLOCK_EFFECT = 1 << 4;
	const BRANCH_EFFECT = 1 << 5;
	const ROOT_EFFECT = 1 << 6;
	const BOUNDARY_EFFECT = 1 << 7;
	const UNOWNED = 1 << 8;
	const DISCONNECTED = 1 << 9;
	const CLEAN = 1 << 10;
	const DIRTY = 1 << 11;
	const MAYBE_DIRTY = 1 << 12;
	const INERT = 1 << 13;
	const DESTROYED = 1 << 14;
	const EFFECT_RAN = 1 << 15;
	/** 'Transparent' effects do not create a transition boundary */
	const EFFECT_TRANSPARENT = 1 << 16;
	const HEAD_EFFECT = 1 << 19;
	const EFFECT_HAS_DERIVED = 1 << 20;
	const EFFECT_IS_UPDATING = 1 << 21;

	const STATE_SYMBOL = Symbol('$state');
	const LEGACY_PROPS = Symbol('legacy props');
	const LOADING_ATTR_SYMBOL = Symbol('');

	/* This file is generated by scripts/process-messages/index.js. Do not edit! */


	/**
	 * Calling `%method%` on a component instance (of %component%) is no longer valid in Svelte 5
	 * @param {string} method
	 * @param {string} component
	 * @returns {never}
	 */
	function component_api_changed(method, component) {
		{
			throw new Error(`https://svelte.dev/e/component_api_changed`);
		}
	}

	/**
	 * Attempted to instantiate %component% with `new %name%`, which is no longer valid in Svelte 5. If this component is not under your control, set the `compatibility.componentApi` compiler option to `4` to keep it working.
	 * @param {string} component
	 * @param {string} name
	 * @returns {never}
	 */
	function component_api_invalid_new(component, name) {
		{
			throw new Error(`https://svelte.dev/e/component_api_invalid_new`);
		}
	}

	/**
	 * `%rune%` cannot be used inside an effect cleanup function
	 * @param {string} rune
	 * @returns {never}
	 */
	function effect_in_teardown(rune) {
		{
			throw new Error(`https://svelte.dev/e/effect_in_teardown`);
		}
	}

	/**
	 * Effect cannot be created inside a `$derived` value that was not itself created inside an effect
	 * @returns {never}
	 */
	function effect_in_unowned_derived() {
		{
			throw new Error(`https://svelte.dev/e/effect_in_unowned_derived`);
		}
	}

	/**
	 * `%rune%` can only be used inside an effect (e.g. during component initialisation)
	 * @param {string} rune
	 * @returns {never}
	 */
	function effect_orphan(rune) {
		{
			throw new Error(`https://svelte.dev/e/effect_orphan`);
		}
	}

	/**
	 * Maximum update depth exceeded. This can happen when a reactive block or effect repeatedly sets a new value. Svelte limits the number of nested updates to prevent infinite loops
	 * @returns {never}
	 */
	function effect_update_depth_exceeded() {
		{
			throw new Error(`https://svelte.dev/e/effect_update_depth_exceeded`);
		}
	}

	/**
	 * Failed to hydrate the application
	 * @returns {never}
	 */
	function hydration_failed() {
		{
			throw new Error(`https://svelte.dev/e/hydration_failed`);
		}
	}

	/**
	 * Cannot do `bind:%key%={undefined}` when `%key%` has a fallback value
	 * @param {string} key
	 * @returns {never}
	 */
	function props_invalid_value(key) {
		{
			throw new Error(`https://svelte.dev/e/props_invalid_value`);
		}
	}

	/**
	 * Property descriptors defined on `$state` objects must contain `value` and always be `enumerable`, `configurable` and `writable`.
	 * @returns {never}
	 */
	function state_descriptors_fixed() {
		{
			throw new Error(`https://svelte.dev/e/state_descriptors_fixed`);
		}
	}

	/**
	 * Cannot set prototype of `$state` object
	 * @returns {never}
	 */
	function state_prototype_fixed() {
		{
			throw new Error(`https://svelte.dev/e/state_prototype_fixed`);
		}
	}

	/**
	 * Updating state inside a derived or a template expression is forbidden. If the value should not be reactive, declare it without `$state`
	 * @returns {never}
	 */
	function state_unsafe_mutation() {
		{
			throw new Error(`https://svelte.dev/e/state_unsafe_mutation`);
		}
	}

	/* This file is generated by scripts/process-messages/index.js. Do not edit! */


	/**
	 * `%binding%` (%location%) is binding to a non-reactive property
	 * @param {string} binding
	 * @param {string | undefined | null} [location]
	 */
	function binding_property_non_reactive(binding, location) {
		{
			console.warn(`https://svelte.dev/e/binding_property_non_reactive`);
		}
	}

	/**
	 * %handler% should be a function. Did you mean to %suggestion%?
	 * @param {string} handler
	 * @param {string} suggestion
	 */
	function event_handler_invalid(handler, suggestion) {
		{
			console.warn(`https://svelte.dev/e/event_handler_invalid`);
		}
	}

	/**
	 * Hydration failed because the initial UI does not match what was rendered on the server. The error occurred near %location%
	 * @param {string | undefined | null} [location]
	 */
	function hydration_mismatch(location) {
		{
			console.warn(`https://svelte.dev/e/hydration_mismatch`);
		}
	}

	/**
	 * %parent% passed property `%prop%` to %child% with `bind:`, but its parent component %owner% did not declare `%prop%` as a binding. Consider creating a binding between %owner% and %parent% (e.g. `bind:%prop%={...}` instead of `%prop%={...}`)
	 * @param {string} parent
	 * @param {string} prop
	 * @param {string} child
	 * @param {string} owner
	 */
	function ownership_invalid_binding(parent, prop, child, owner) {
		{
			console.warn(`https://svelte.dev/e/ownership_invalid_binding`);
		}
	}

	/**
	 * Mutating unbound props (`%name%`, at %location%) is strongly discouraged. Consider using `bind:%prop%={...}` in %parent% (or using a callback) instead
	 * @param {string} name
	 * @param {string} location
	 * @param {string} prop
	 * @param {string} parent
	 */
	function ownership_invalid_mutation(name, location, prop, parent) {
		{
			console.warn(`https://svelte.dev/e/ownership_invalid_mutation`);
		}
	}

	/**
	 * Reactive `$state(...)` proxies and the values they proxy have different identities. Because of this, comparisons with `%operator%` will produce unexpected results
	 * @param {string} operator
	 */
	function state_proxy_equality_mismatch(operator) {
		{
			console.warn(`https://svelte.dev/e/state_proxy_equality_mismatch`);
		}
	}

	/** @import { TemplateNode } from '#client' */


	/**
	 * Use this variable to guard everything related to hydration code so it can be treeshaken out
	 * if the user doesn't use the `hydrate` method and these code paths are therefore not needed.
	 */
	let hydrating = false;

	/** @param {boolean} value */
	function set_hydrating(value) {
		hydrating = value;
	}

	/**
	 * The node that is currently being hydrated. This starts out as the first node inside the opening
	 * <!--[--> comment, and updates each time a component calls `$.child(...)` or `$.sibling(...)`.
	 * When entering a block (e.g. `{#if ...}`), `hydrate_node` is the block opening comment; by the
	 * time we leave the block it is the closing comment, which serves as the block's anchor.
	 * @type {TemplateNode}
	 */
	let hydrate_node;

	/** @param {TemplateNode} node */
	function set_hydrate_node(node) {
		if (node === null) {
			hydration_mismatch();
			throw HYDRATION_ERROR;
		}

		return (hydrate_node = node);
	}

	function hydrate_next() {
		return set_hydrate_node(/** @type {TemplateNode} */ (get_next_sibling(hydrate_node)));
	}

	/** @param {TemplateNode} node */
	function reset(node) {
		if (!hydrating) return;

		// If the node has remaining siblings, something has gone wrong
		if (get_next_sibling(hydrate_node) !== null) {
			hydration_mismatch();
			throw HYDRATION_ERROR;
		}

		hydrate_node = node;
	}

	/**
	 * Removes all nodes starting at `hydrate_node` up until the next hydration end comment
	 */
	function remove_nodes() {
		var depth = 0;
		var node = hydrate_node;

		while (true) {
			if (node.nodeType === 8) {
				var data = /** @type {Comment} */ (node).data;

				if (data === HYDRATION_END) {
					if (depth === 0) return node;
					depth -= 1;
				} else if (data === HYDRATION_START || data === HYDRATION_START_ELSE) {
					depth += 1;
				}
			}

			var next = /** @type {TemplateNode} */ (get_next_sibling(node));
			node.remove();
			node = next;
		}
	}

	/* This file is generated by scripts/process-messages/index.js. Do not edit! */


	/**
	 * `<svelte:element this="%tag%">` is a void element — it cannot have content
	 * @param {string} tag
	 */
	function dynamic_void_element_content(tag) {
		{
			console.warn(`https://svelte.dev/e/dynamic_void_element_content`);
		}
	}

	let tracing_mode_flag = false;

	/** @import { Source } from '#client' */

	/**
	 * @template T
	 * @param {T} value
	 * @returns {T}
	 */
	function proxy(value) {
		// if non-proxyable, or is already a proxy, return `value`
		if (typeof value !== 'object' || value === null || STATE_SYMBOL in value) {
			return value;
		}

		const prototype = get_prototype_of(value);

		if (prototype !== object_prototype && prototype !== array_prototype) {
			return value;
		}

		/** @type {Map<any, Source<any>>} */
		var sources = new Map();
		var is_proxied_array = is_array(value);
		var version = state(0);
		var reaction = active_reaction;

		/**
		 * @template T
		 * @param {() => T} fn
		 */
		var with_parent = (fn) => {
			var previous_reaction = active_reaction;
			set_active_reaction(reaction);

			/** @type {T} */
			var result = fn();

			set_active_reaction(previous_reaction);
			return result;
		};

		if (is_proxied_array) {
			// We need to create the length source eagerly to ensure that
			// mutations to the array are properly synced with our proxy
			sources.set('length', state(/** @type {any[]} */ (value).length));
		}

		return new Proxy(/** @type {any} */ (value), {
			defineProperty(_, prop, descriptor) {
				if (
					!('value' in descriptor) ||
					descriptor.configurable === false ||
					descriptor.enumerable === false ||
					descriptor.writable === false
				) {
					// we disallow non-basic descriptors, because unless they are applied to the
					// target object — which we avoid, so that state can be forked — we will run
					// afoul of the various invariants
					// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/getOwnPropertyDescriptor#invariants
					state_descriptors_fixed();
				}

				var s = sources.get(prop);

				if (s === undefined) {
					s = with_parent(() => state(descriptor.value));
					sources.set(prop, s);
				} else {
					set(
						s,
						with_parent(() => proxy(descriptor.value))
					);
				}

				return true;
			},

			deleteProperty(target, prop) {
				var s = sources.get(prop);

				if (s === undefined) {
					if (prop in target) {
						sources.set(
							prop,
							with_parent(() => state(UNINITIALIZED))
						);
						update_version(version);
					}
				} else {
					// When working with arrays, we need to also ensure we update the length when removing
					// an indexed property
					if (is_proxied_array && typeof prop === 'string') {
						var ls = /** @type {Source<number>} */ (sources.get('length'));
						var n = Number(prop);

						if (Number.isInteger(n) && n < ls.v) {
							set(ls, n);
						}
					}
					set(s, UNINITIALIZED);
					update_version(version);
				}

				return true;
			},

			get(target, prop, receiver) {
				if (prop === STATE_SYMBOL) {
					return value;
				}

				var s = sources.get(prop);
				var exists = prop in target;

				// create a source, but only if it's an own property and not a prototype property
				if (s === undefined && (!exists || get_descriptor(target, prop)?.writable)) {
					s = with_parent(() => state(proxy(exists ? target[prop] : UNINITIALIZED)));
					sources.set(prop, s);
				}

				if (s !== undefined) {
					var v = get(s);
					return v === UNINITIALIZED ? undefined : v;
				}

				return Reflect.get(target, prop, receiver);
			},

			getOwnPropertyDescriptor(target, prop) {
				var descriptor = Reflect.getOwnPropertyDescriptor(target, prop);

				if (descriptor && 'value' in descriptor) {
					var s = sources.get(prop);
					if (s) descriptor.value = get(s);
				} else if (descriptor === undefined) {
					var source = sources.get(prop);
					var value = source?.v;

					if (source !== undefined && value !== UNINITIALIZED) {
						return {
							enumerable: true,
							configurable: true,
							value,
							writable: true
						};
					}
				}

				return descriptor;
			},

			has(target, prop) {
				if (prop === STATE_SYMBOL) {
					return true;
				}

				var s = sources.get(prop);
				var has = (s !== undefined && s.v !== UNINITIALIZED) || Reflect.has(target, prop);

				if (
					s !== undefined ||
					(active_effect !== null && (!has || get_descriptor(target, prop)?.writable))
				) {
					if (s === undefined) {
						s = with_parent(() => state(has ? proxy(target[prop]) : UNINITIALIZED));
						sources.set(prop, s);
					}

					var value = get(s);
					if (value === UNINITIALIZED) {
						return false;
					}
				}

				return has;
			},

			set(target, prop, value, receiver) {
				var s = sources.get(prop);
				var has = prop in target;

				// variable.length = value -> clear all signals with index >= value
				if (is_proxied_array && prop === 'length') {
					for (var i = value; i < /** @type {Source<number>} */ (s).v; i += 1) {
						var other_s = sources.get(i + '');
						if (other_s !== undefined) {
							set(other_s, UNINITIALIZED);
						} else if (i in target) {
							// If the item exists in the original, we need to create a uninitialized source,
							// else a later read of the property would result in a source being created with
							// the value of the original item at that index.
							other_s = with_parent(() => state(UNINITIALIZED));
							sources.set(i + '', other_s);
						}
					}
				}

				// If we haven't yet created a source for this property, we need to ensure
				// we do so otherwise if we read it later, then the write won't be tracked and
				// the heuristics of effects will be different vs if we had read the proxied
				// object property before writing to that property.
				if (s === undefined) {
					if (!has || get_descriptor(target, prop)?.writable) {
						s = with_parent(() => state(undefined));
						set(
							s,
							with_parent(() => proxy(value))
						);
						sources.set(prop, s);
					}
				} else {
					has = s.v !== UNINITIALIZED;
					set(
						s,
						with_parent(() => proxy(value))
					);
				}

				var descriptor = Reflect.getOwnPropertyDescriptor(target, prop);

				// Set the new value before updating any signals so that any listeners get the new value
				if (descriptor?.set) {
					descriptor.set.call(receiver, value);
				}

				if (!has) {
					// If we have mutated an array directly, we might need to
					// signal that length has also changed. Do it before updating metadata
					// to ensure that iterating over the array as a result of a metadata update
					// will not cause the length to be out of sync.
					if (is_proxied_array && typeof prop === 'string') {
						var ls = /** @type {Source<number>} */ (sources.get('length'));
						var n = Number(prop);

						if (Number.isInteger(n) && n >= ls.v) {
							set(ls, n + 1);
						}
					}

					update_version(version);
				}

				return true;
			},

			ownKeys(target) {
				get(version);

				var own_keys = Reflect.ownKeys(target).filter((key) => {
					var source = sources.get(key);
					return source === undefined || source.v !== UNINITIALIZED;
				});

				for (var [key, source] of sources) {
					if (source.v !== UNINITIALIZED && !(key in target)) {
						own_keys.push(key);
					}
				}

				return own_keys;
			},

			setPrototypeOf() {
				state_prototype_fixed();
			}
		});
	}

	/**
	 * @param {Source<number>} signal
	 * @param {1 | -1} [d]
	 */
	function update_version(signal, d = 1) {
		set(signal, signal.v + d);
	}

	/**
	 * @param {any} value
	 */
	function get_proxied_value(value) {
		try {
			if (value !== null && typeof value === 'object' && STATE_SYMBOL in value) {
				return value[STATE_SYMBOL];
			}
		} catch {
			// the above if check can throw an error if the value in question
			// is the contentWindow of an iframe on another domain, in which
			// case we want to just return the value (because it's definitely
			// not a proxied value) so we don't break any JavaScript interacting
			// with that iframe (such as various payment companies client side
			// JavaScript libraries interacting with their iframes on the same
			// domain)
		}

		return value;
	}

	/**
	 * @param {any} a
	 * @param {any} b
	 */
	function is(a, b) {
		return Object.is(get_proxied_value(a), get_proxied_value(b));
	}

	/**
	 * @param {any} a
	 * @param {any} b
	 * @param {boolean} equal
	 * @returns {boolean}
	 */
	function strict_equals(a, b, equal = true) {
		// try-catch needed because this tries to read properties of `a` and `b`,
		// which could be disallowed for example in a secure context
		try {
			if ((a === b) !== (get_proxied_value(a) === get_proxied_value(b))) {
				state_proxy_equality_mismatch(equal ? '===' : '!==');
			}
		} catch {}

		return (a === b) === equal;
	}

	/**
	 * @param {any} a
	 * @param {any} b
	 * @param {boolean} equal
	 * @returns {boolean}
	 */
	function equals$1(a, b, equal = true) {
		if ((a == b) !== (get_proxied_value(a) == get_proxied_value(b))) {
			state_proxy_equality_mismatch();
		}

		return (a == b) === equal;
	}

	/** @import { TemplateNode } from '#client' */

	// export these for reference in the compiled code, making global name deduplication unnecessary
	/** @type {Window} */
	var $window;

	/** @type {boolean} */
	var is_firefox;

	/** @type {() => Node | null} */
	var first_child_getter;
	/** @type {() => Node | null} */
	var next_sibling_getter;

	/**
	 * Initialize these lazily to avoid issues when using the runtime in a server context
	 * where these globals are not available while avoiding a separate server entry point
	 */
	function init_operations() {
		if ($window !== undefined) {
			return;
		}

		$window = window;
		is_firefox = /Firefox/.test(navigator.userAgent);

		var element_prototype = Element.prototype;
		var node_prototype = Node.prototype;
		var text_prototype = Text.prototype;

		// @ts-ignore
		first_child_getter = get_descriptor(node_prototype, 'firstChild').get;
		// @ts-ignore
		next_sibling_getter = get_descriptor(node_prototype, 'nextSibling').get;

		if (is_extensible(element_prototype)) {
			// the following assignments improve perf of lookups on DOM nodes
			// @ts-expect-error
			element_prototype.__click = undefined;
			// @ts-expect-error
			element_prototype.__className = undefined;
			// @ts-expect-error
			element_prototype.__attributes = null;
			// @ts-expect-error
			element_prototype.__style = undefined;
			// @ts-expect-error
			element_prototype.__e = undefined;
		}

		if (is_extensible(text_prototype)) {
			// @ts-expect-error
			text_prototype.__t = undefined;
		}
	}

	/**
	 * @param {string} value
	 * @returns {Text}
	 */
	function create_text(value = '') {
		return document.createTextNode(value);
	}

	/**
	 * @template {Node} N
	 * @param {N} node
	 * @returns {Node | null}
	 */
	/*@__NO_SIDE_EFFECTS__*/
	function get_first_child(node) {
		return first_child_getter.call(node);
	}

	/**
	 * @template {Node} N
	 * @param {N} node
	 * @returns {Node | null}
	 */
	/*@__NO_SIDE_EFFECTS__*/
	function get_next_sibling(node) {
		return next_sibling_getter.call(node);
	}

	/**
	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
	 * @template {Node} N
	 * @param {N} node
	 * @param {boolean} is_text
	 * @returns {Node | null}
	 */
	function child(node, is_text) {
		if (!hydrating) {
			return get_first_child(node);
		}

		var child = /** @type {TemplateNode} */ (get_first_child(hydrate_node));

		// Child can be null if we have an element with a single child, like `<p>{text}</p>`, where `text` is empty
		if (child === null) {
			child = hydrate_node.appendChild(create_text());
		} else if (is_text && child.nodeType !== 3) {
			var text = create_text();
			child?.before(text);
			set_hydrate_node(text);
			return text;
		}

		set_hydrate_node(child);
		return child;
	}

	/**
	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
	 * @param {DocumentFragment | TemplateNode[]} fragment
	 * @param {boolean} is_text
	 * @returns {Node | null}
	 */
	function first_child(fragment, is_text) {
		if (!hydrating) {
			// when not hydrating, `fragment` is a `DocumentFragment` (the result of calling `open_frag`)
			var first = /** @type {DocumentFragment} */ (get_first_child(/** @type {Node} */ (fragment)));

			// TODO prevent user comments with the empty string when preserveComments is true
			if (first instanceof Comment && first.data === '') return get_next_sibling(first);

			return first;
		}

		return hydrate_node;
	}

	/**
	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
	 * @param {TemplateNode} node
	 * @param {number} count
	 * @param {boolean} is_text
	 * @returns {Node | null}
	 */
	function sibling(node, count = 1, is_text = false) {
		let next_sibling = hydrating ? hydrate_node : node;
		var last_sibling;

		while (count--) {
			last_sibling = next_sibling;
			next_sibling = /** @type {TemplateNode} */ (get_next_sibling(next_sibling));
		}

		if (!hydrating) {
			return next_sibling;
		}

		var type = next_sibling?.nodeType;

		// if a sibling {expression} is empty during SSR, there might be no
		// text node to hydrate — we must therefore create one
		if (is_text && type !== 3) {
			var text = create_text();
			// If the next sibling is `null` and we're handling text then it's because
			// the SSR content was empty for the text, so we need to generate a new text
			// node and insert it after the last sibling
			if (next_sibling === null) {
				last_sibling?.after(text);
			} else {
				next_sibling.before(text);
			}
			set_hydrate_node(text);
			return text;
		}

		set_hydrate_node(next_sibling);
		return /** @type {TemplateNode} */ (next_sibling);
	}

	/**
	 * @template {Node} N
	 * @param {N} node
	 * @returns {void}
	 */
	function clear_text_content(node) {
		node.textContent = '';
	}

	/** @import { Equals } from '#client' */

	/** @type {Equals} */
	function equals(value) {
		return value === this.v;
	}

	/**
	 * @param {unknown} a
	 * @param {unknown} b
	 * @returns {boolean}
	 */
	function safe_not_equal(a, b) {
		return a != a
			? b == b
			: a !== b || (a !== null && typeof a === 'object') || typeof a === 'function';
	}

	/** @type {Equals} */
	function safe_equals(value) {
		return !safe_not_equal(value, this.v);
	}

	/** @import { Derived, Effect } from '#client' */

	/**
	 * @template V
	 * @param {() => V} fn
	 * @returns {Derived<V>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function derived(fn) {
		var flags = DERIVED | DIRTY;
		var parent_derived =
			active_reaction !== null && (active_reaction.f & DERIVED) !== 0
				? /** @type {Derived} */ (active_reaction)
				: null;

		if (active_effect === null || (parent_derived !== null && (parent_derived.f & UNOWNED) !== 0)) {
			flags |= UNOWNED;
		} else {
			// Since deriveds are evaluated lazily, any effects created inside them are
			// created too late to ensure that the parent effect is added to the tree
			active_effect.f |= EFFECT_HAS_DERIVED;
		}

		/** @type {Derived<V>} */
		const signal = {
			ctx: component_context,
			deps: null,
			effects: null,
			equals,
			f: flags,
			fn,
			reactions: null,
			rv: 0,
			v: /** @type {V} */ (null),
			wv: 0,
			parent: parent_derived ?? active_effect
		};

		return signal;
	}

	/**
	 * @template V
	 * @param {() => V} fn
	 * @returns {Derived<V>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function user_derived(fn) {
		const d = derived(fn);

		push_reaction_value(d);

		return d;
	}

	/**
	 * @template V
	 * @param {() => V} fn
	 * @returns {Derived<V>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function derived_safe_equal(fn) {
		const signal = derived(fn);
		signal.equals = safe_equals;
		return signal;
	}

	/**
	 * @param {Derived} derived
	 * @returns {void}
	 */
	function destroy_derived_effects(derived) {
		var effects = derived.effects;

		if (effects !== null) {
			derived.effects = null;

			for (var i = 0; i < effects.length; i += 1) {
				destroy_effect(/** @type {Effect} */ (effects[i]));
			}
		}
	}

	/**
	 * @param {Derived} derived
	 * @returns {Effect | null}
	 */
	function get_derived_parent_effect(derived) {
		var parent = derived.parent;
		while (parent !== null) {
			if ((parent.f & DERIVED) === 0) {
				return /** @type {Effect} */ (parent);
			}
			parent = parent.parent;
		}
		return null;
	}

	/**
	 * @template T
	 * @param {Derived} derived
	 * @returns {T}
	 */
	function execute_derived(derived) {
		var value;
		var prev_active_effect = active_effect;

		set_active_effect(get_derived_parent_effect(derived));

		{
			try {
				destroy_derived_effects(derived);
				value = update_reaction(derived);
			} finally {
				set_active_effect(prev_active_effect);
			}
		}

		return value;
	}

	/**
	 * @param {Derived} derived
	 * @returns {void}
	 */
	function update_derived(derived) {
		var value = execute_derived(derived);
		var status =
			(skip_reaction || (derived.f & UNOWNED) !== 0) && derived.deps !== null ? MAYBE_DIRTY : CLEAN;

		set_signal_status(derived, status);

		if (!derived.equals(value)) {
			derived.v = value;
			derived.wv = increment_write_version();
		}
	}

	/** @import { ComponentContext, ComponentContextLegacy, Derived, Effect, TemplateNode, TransitionManager } from '#client' */

	/**
	 * @param {'$effect' | '$effect.pre' | '$inspect'} rune
	 */
	function validate_effect(rune) {
		if (active_effect === null && active_reaction === null) {
			effect_orphan();
		}

		if (active_reaction !== null && (active_reaction.f & UNOWNED) !== 0 && active_effect === null) {
			effect_in_unowned_derived();
		}

		if (is_destroying_effect) {
			effect_in_teardown();
		}
	}

	/**
	 * @param {Effect} effect
	 * @param {Effect} parent_effect
	 */
	function push_effect(effect, parent_effect) {
		var parent_last = parent_effect.last;
		if (parent_last === null) {
			parent_effect.last = parent_effect.first = effect;
		} else {
			parent_last.next = effect;
			effect.prev = parent_last;
			parent_effect.last = effect;
		}
	}

	/**
	 * @param {number} type
	 * @param {null | (() => void | (() => void))} fn
	 * @param {boolean} sync
	 * @param {boolean} push
	 * @returns {Effect}
	 */
	function create_effect(type, fn, sync, push = true) {
		var parent = active_effect;

		/** @type {Effect} */
		var effect = {
			ctx: component_context,
			deps: null,
			nodes_start: null,
			nodes_end: null,
			f: type | DIRTY,
			first: null,
			fn,
			last: null,
			next: null,
			parent,
			prev: null,
			teardown: null,
			transitions: null,
			wv: 0
		};

		if (sync) {
			try {
				update_effect(effect);
				effect.f |= EFFECT_RAN;
			} catch (e) {
				destroy_effect(effect);
				throw e;
			}
		} else if (fn !== null) {
			schedule_effect(effect);
		}

		// if an effect has no dependencies, no DOM and no teardown function,
		// don't bother adding it to the effect tree
		var inert =
			sync &&
			effect.deps === null &&
			effect.first === null &&
			effect.nodes_start === null &&
			effect.teardown === null &&
			(effect.f & (EFFECT_HAS_DERIVED | BOUNDARY_EFFECT)) === 0;

		if (!inert && push) {
			if (parent !== null) {
				push_effect(effect, parent);
			}

			// if we're in a derived, add the effect there too
			if (active_reaction !== null && (active_reaction.f & DERIVED) !== 0) {
				var derived = /** @type {Derived} */ (active_reaction);
				(derived.effects ??= []).push(effect);
			}
		}

		return effect;
	}

	/**
	 * @param {() => void} fn
	 */
	function teardown(fn) {
		const effect = create_effect(RENDER_EFFECT, null, false);
		set_signal_status(effect, CLEAN);
		effect.teardown = fn;
		return effect;
	}

	/**
	 * Internal representation of `$effect(...)`
	 * @param {() => void | (() => void)} fn
	 */
	function user_effect(fn) {
		validate_effect();

		// Non-nested `$effect(...)` in a component should be deferred
		// until the component is mounted
		var defer =
			active_effect !== null &&
			(active_effect.f & BRANCH_EFFECT) !== 0 &&
			component_context !== null &&
			!component_context.m;

		if (defer) {
			var context = /** @type {ComponentContext} */ (component_context);
			(context.e ??= []).push({
				fn,
				effect: active_effect,
				reaction: active_reaction
			});
		} else {
			var signal = effect(fn);
			return signal;
		}
	}

	/**
	 * Internal representation of `$effect.root(...)`
	 * @param {() => void | (() => void)} fn
	 * @returns {() => void}
	 */
	function effect_root(fn) {
		const effect = create_effect(ROOT_EFFECT, fn, true);

		return () => {
			destroy_effect(effect);
		};
	}

	/**
	 * An effect root whose children can transition out
	 * @param {() => void} fn
	 * @returns {(options?: { outro?: boolean }) => Promise<void>}
	 */
	function component_root(fn) {
		const effect = create_effect(ROOT_EFFECT, fn, true);

		return (options = {}) => {
			return new Promise((fulfil) => {
				if (options.outro) {
					pause_effect(effect, () => {
						destroy_effect(effect);
						fulfil(undefined);
					});
				} else {
					destroy_effect(effect);
					fulfil(undefined);
				}
			});
		};
	}

	/**
	 * @param {() => void | (() => void)} fn
	 * @returns {Effect}
	 */
	function effect(fn) {
		return create_effect(EFFECT, fn, false);
	}

	/**
	 * @param {() => void | (() => void)} fn
	 * @returns {Effect}
	 */
	function render_effect(fn) {
		return create_effect(RENDER_EFFECT, fn, true);
	}

	/**
	 * @param {(...expressions: any) => void | (() => void)} fn
	 * @param {Array<() => any>} thunks
	 * @returns {Effect}
	 */
	function template_effect(fn, thunks = [], d = derived) {
		const deriveds = thunks.map(d);
		const effect = () => fn(...deriveds.map(get));

		return block(effect);
	}

	/**
	 * @param {(() => void)} fn
	 * @param {number} flags
	 */
	function block(fn, flags = 0) {
		return create_effect(RENDER_EFFECT | BLOCK_EFFECT | flags, fn, true);
	}

	/**
	 * @param {(() => void)} fn
	 * @param {boolean} [push]
	 */
	function branch(fn, push = true) {
		return create_effect(RENDER_EFFECT | BRANCH_EFFECT, fn, true, push);
	}

	/**
	 * @param {Effect} effect
	 */
	function execute_effect_teardown(effect) {
		var teardown = effect.teardown;
		if (teardown !== null) {
			const previously_destroying_effect = is_destroying_effect;
			const previous_reaction = active_reaction;
			set_is_destroying_effect(true);
			set_active_reaction(null);
			try {
				teardown.call(null);
			} finally {
				set_is_destroying_effect(previously_destroying_effect);
				set_active_reaction(previous_reaction);
			}
		}
	}

	/**
	 * @param {Effect} signal
	 * @param {boolean} remove_dom
	 * @returns {void}
	 */
	function destroy_effect_children(signal, remove_dom = false) {
		var effect = signal.first;
		signal.first = signal.last = null;

		while (effect !== null) {
			var next = effect.next;

			if ((effect.f & ROOT_EFFECT) !== 0) {
				// this is now an independent root
				effect.parent = null;
			} else {
				destroy_effect(effect, remove_dom);
			}

			effect = next;
		}
	}

	/**
	 * @param {Effect} signal
	 * @returns {void}
	 */
	function destroy_block_effect_children(signal) {
		var effect = signal.first;

		while (effect !== null) {
			var next = effect.next;
			if ((effect.f & BRANCH_EFFECT) === 0) {
				destroy_effect(effect);
			}
			effect = next;
		}
	}

	/**
	 * @param {Effect} effect
	 * @param {boolean} [remove_dom]
	 * @returns {void}
	 */
	function destroy_effect(effect, remove_dom = true) {
		var removed = false;

		if ((remove_dom || (effect.f & HEAD_EFFECT) !== 0) && effect.nodes_start !== null) {
			remove_effect_dom(effect.nodes_start, /** @type {TemplateNode} */ (effect.nodes_end));
			removed = true;
		}

		destroy_effect_children(effect, remove_dom && !removed);
		remove_reactions(effect, 0);
		set_signal_status(effect, DESTROYED);

		var transitions = effect.transitions;

		if (transitions !== null) {
			for (const transition of transitions) {
				transition.stop();
			}
		}

		execute_effect_teardown(effect);

		var parent = effect.parent;

		// If the parent doesn't have any children, then skip this work altogether
		if (parent !== null && parent.first !== null) {
			unlink_effect(effect);
		}

		// `first` and `child` are nulled out in destroy_effect_children
		// we don't null out `parent` so that error propagation can work correctly
		effect.next =
			effect.prev =
			effect.teardown =
			effect.ctx =
			effect.deps =
			effect.fn =
			effect.nodes_start =
			effect.nodes_end =
				null;
	}

	/**
	 *
	 * @param {TemplateNode | null} node
	 * @param {TemplateNode} end
	 */
	function remove_effect_dom(node, end) {
		while (node !== null) {
			/** @type {TemplateNode | null} */
			var next = node === end ? null : /** @type {TemplateNode} */ (get_next_sibling(node));

			node.remove();
			node = next;
		}
	}

	/**
	 * Detach an effect from the effect tree, freeing up memory and
	 * reducing the amount of work that happens on subsequent traversals
	 * @param {Effect} effect
	 */
	function unlink_effect(effect) {
		var parent = effect.parent;
		var prev = effect.prev;
		var next = effect.next;

		if (prev !== null) prev.next = next;
		if (next !== null) next.prev = prev;

		if (parent !== null) {
			if (parent.first === effect) parent.first = next;
			if (parent.last === effect) parent.last = prev;
		}
	}

	/**
	 * When a block effect is removed, we don't immediately destroy it or yank it
	 * out of the DOM, because it might have transitions. Instead, we 'pause' it.
	 * It stays around (in memory, and in the DOM) until outro transitions have
	 * completed, and if the state change is reversed then we _resume_ it.
	 * A paused effect does not update, and the DOM subtree becomes inert.
	 * @param {Effect} effect
	 * @param {() => void} [callback]
	 */
	function pause_effect(effect, callback) {
		/** @type {TransitionManager[]} */
		var transitions = [];

		pause_children(effect, transitions, true);

		run_out_transitions(transitions, () => {
			destroy_effect(effect);
			if (callback) callback();
		});
	}

	/**
	 * @param {TransitionManager[]} transitions
	 * @param {() => void} fn
	 */
	function run_out_transitions(transitions, fn) {
		var remaining = transitions.length;
		if (remaining > 0) {
			var check = () => --remaining || fn();
			for (var transition of transitions) {
				transition.out(check);
			}
		} else {
			fn();
		}
	}

	/**
	 * @param {Effect} effect
	 * @param {TransitionManager[]} transitions
	 * @param {boolean} local
	 */
	function pause_children(effect, transitions, local) {
		if ((effect.f & INERT) !== 0) return;
		effect.f ^= INERT;

		if (effect.transitions !== null) {
			for (const transition of effect.transitions) {
				if (transition.is_global || local) {
					transitions.push(transition);
				}
			}
		}

		var child = effect.first;

		while (child !== null) {
			var sibling = child.next;
			var transparent = (child.f & EFFECT_TRANSPARENT) !== 0 || (child.f & BRANCH_EFFECT) !== 0;
			// TODO we don't need to call pause_children recursively with a linked list in place
			// it's slightly more involved though as we have to account for `transparent` changing
			// through the tree.
			pause_children(child, transitions, transparent ? local : false);
			child = sibling;
		}
	}

	/**
	 * The opposite of `pause_effect`. We call this if (for example)
	 * `x` becomes falsy then truthy: `{#if x}...{/if}`
	 * @param {Effect} effect
	 */
	function resume_effect(effect) {
		resume_children(effect, true);
	}

	/**
	 * @param {Effect} effect
	 * @param {boolean} local
	 */
	function resume_children(effect, local) {
		if ((effect.f & INERT) === 0) return;
		effect.f ^= INERT;

		// Ensure the effect is marked as clean again so that any dirty child
		// effects can schedule themselves for execution
		if ((effect.f & CLEAN) === 0) {
			effect.f ^= CLEAN;
		}

		// If a dependency of this effect changed while it was paused,
		// schedule the effect to update
		if (check_dirtiness(effect)) {
			set_signal_status(effect, DIRTY);
			schedule_effect(effect);
		}

		var child = effect.first;

		while (child !== null) {
			var sibling = child.next;
			var transparent = (child.f & EFFECT_TRANSPARENT) !== 0 || (child.f & BRANCH_EFFECT) !== 0;
			// TODO we don't need to call resume_children recursively with a linked list in place
			// it's slightly more involved though as we have to account for `transparent` changing
			// through the tree.
			resume_children(child, transparent ? local : false);
			child = sibling;
		}

		if (effect.transitions !== null) {
			for (const transition of effect.transitions) {
				if (transition.is_global || local) {
					transition.in();
				}
			}
		}
	}

	// Fallback for when requestIdleCallback is not available
	const request_idle_callback =
		typeof requestIdleCallback === 'undefined'
			? (/** @type {() => void} */ cb) => setTimeout(cb, 1)
			: requestIdleCallback;

	/** @type {Array<() => void>} */
	let micro_tasks = [];

	/** @type {Array<() => void>} */
	let idle_tasks = [];

	function run_micro_tasks() {
		var tasks = micro_tasks;
		micro_tasks = [];
		run_all(tasks);
	}

	function run_idle_tasks() {
		var tasks = idle_tasks;
		idle_tasks = [];
		run_all(tasks);
	}

	/**
	 * @param {() => void} fn
	 */
	function queue_micro_task(fn) {
		if (micro_tasks.length === 0) {
			queueMicrotask(run_micro_tasks);
		}

		micro_tasks.push(fn);
	}

	/**
	 * @param {() => void} fn
	 */
	function queue_idle_task(fn) {
		if (idle_tasks.length === 0) {
			request_idle_callback(run_idle_tasks);
		}

		idle_tasks.push(fn);
	}

	/**
	 * Synchronously run any queued tasks.
	 */
	function flush_tasks() {
		if (micro_tasks.length > 0) {
			run_micro_tasks();
		}

		if (idle_tasks.length > 0) {
			run_idle_tasks();
		}
	}

	/** @import { ComponentContext, Derived, Effect, Reaction, Signal, Source, Value } from '#client' */
	let is_throwing_error = false;

	let is_flushing = false;

	/** @type {Effect | null} */
	let last_scheduled_effect = null;

	let is_updating_effect = false;

	let is_destroying_effect = false;

	/** @param {boolean} value */
	function set_is_destroying_effect(value) {
		is_destroying_effect = value;
	}

	// Handle effect queues

	/** @type {Effect[]} */
	let queued_root_effects = [];

	/** @type {Effect[]} Stack of effects, dev only */
	let dev_effect_stack = [];
	// Handle signal reactivity tree dependencies and reactions

	/** @type {null | Reaction} */
	let active_reaction = null;

	let untracking = false;

	/** @param {null | Reaction} reaction */
	function set_active_reaction(reaction) {
		active_reaction = reaction;
	}

	/** @type {null | Effect} */
	let active_effect = null;

	/** @param {null | Effect} effect */
	function set_active_effect(effect) {
		active_effect = effect;
	}

	/**
	 * When sources are created within a reaction, reading and writing
	 * them should not cause a re-run
	 * @type {null | Source[]}
	 */
	let reaction_sources = null;

	/** @param {Value} value */
	function push_reaction_value(value) {
		if (active_reaction !== null && active_reaction.f & EFFECT_IS_UPDATING) {
			if (reaction_sources === null) {
				reaction_sources = [value];
			} else {
				reaction_sources.push(value);
			}
		}
	}

	/**
	 * The dependencies of the reaction that is currently being executed. In many cases,
	 * the dependencies are unchanged between runs, and so this will be `null` unless
	 * and until a new dependency is accessed — we track this via `skipped_deps`
	 * @type {null | Value[]}
	 */
	let new_deps = null;

	let skipped_deps = 0;

	/**
	 * Tracks writes that the effect it's executed in doesn't listen to yet,
	 * so that the dependency can be added to the effect later on if it then reads it
	 * @type {null | Source[]}
	 */
	let untracked_writes = null;

	/** @param {null | Source[]} value */
	function set_untracked_writes(value) {
		untracked_writes = value;
	}

	/**
	 * @type {number} Used by sources and deriveds for handling updates.
	 * Version starts from 1 so that unowned deriveds differentiate between a created effect and a run one for tracing
	 **/
	let write_version = 1;

	/** @type {number} Used to version each read of a source of derived to avoid duplicating depedencies inside a reaction */
	let read_version = 0;

	// If we are working with a get() chain that has no active container,
	// to prevent memory leaks, we skip adding the reaction.
	let skip_reaction = false;

	function increment_write_version() {
		return ++write_version;
	}

	/**
	 * Determines whether a derived or effect is dirty.
	 * If it is MAYBE_DIRTY, will set the status to CLEAN
	 * @param {Reaction} reaction
	 * @returns {boolean}
	 */
	function check_dirtiness(reaction) {
		var flags = reaction.f;

		if ((flags & DIRTY) !== 0) {
			return true;
		}

		if ((flags & MAYBE_DIRTY) !== 0) {
			var dependencies = reaction.deps;
			var is_unowned = (flags & UNOWNED) !== 0;

			if (dependencies !== null) {
				var i;
				var dependency;
				var is_disconnected = (flags & DISCONNECTED) !== 0;
				var is_unowned_connected = is_unowned && active_effect !== null && !skip_reaction;
				var length = dependencies.length;

				// If we are working with a disconnected or an unowned signal that is now connected (due to an active effect)
				// then we need to re-connect the reaction to the dependency
				if (is_disconnected || is_unowned_connected) {
					var derived = /** @type {Derived} */ (reaction);
					var parent = derived.parent;

					for (i = 0; i < length; i++) {
						dependency = dependencies[i];

						// We always re-add all reactions (even duplicates) if the derived was
						// previously disconnected, however we don't if it was unowned as we
						// de-duplicate dependencies in that case
						if (is_disconnected || !dependency?.reactions?.includes(derived)) {
							(dependency.reactions ??= []).push(derived);
						}
					}

					if (is_disconnected) {
						derived.f ^= DISCONNECTED;
					}
					// If the unowned derived is now fully connected to the graph again (it's unowned and reconnected, has a parent
					// and the parent is not unowned), then we can mark it as connected again, removing the need for the unowned
					// flag
					if (is_unowned_connected && parent !== null && (parent.f & UNOWNED) === 0) {
						derived.f ^= UNOWNED;
					}
				}

				for (i = 0; i < length; i++) {
					dependency = dependencies[i];

					if (check_dirtiness(/** @type {Derived} */ (dependency))) {
						update_derived(/** @type {Derived} */ (dependency));
					}

					if (dependency.wv > reaction.wv) {
						return true;
					}
				}
			}

			// Unowned signals should never be marked as clean unless they
			// are used within an active_effect without skip_reaction
			if (!is_unowned || (active_effect !== null && !skip_reaction)) {
				set_signal_status(reaction, CLEAN);
			}
		}

		return false;
	}

	/**
	 * @param {unknown} error
	 * @param {Effect} effect
	 */
	function propagate_error(error, effect) {
		/** @type {Effect | null} */
		var current = effect;

		while (current !== null) {
			if ((current.f & BOUNDARY_EFFECT) !== 0) {
				try {
					// @ts-expect-error
					current.fn(error);
					return;
				} catch {
					// Remove boundary flag from effect
					current.f ^= BOUNDARY_EFFECT;
				}
			}

			current = current.parent;
		}

		is_throwing_error = false;
		throw error;
	}

	/**
	 * @param {Effect} effect
	 */
	function should_rethrow_error(effect) {
		return (
			(effect.f & DESTROYED) === 0 &&
			(effect.parent === null || (effect.parent.f & BOUNDARY_EFFECT) === 0)
		);
	}

	/**
	 * @param {unknown} error
	 * @param {Effect} effect
	 * @param {Effect | null} previous_effect
	 * @param {ComponentContext | null} component_context
	 */
	function handle_error(error, effect, previous_effect, component_context) {
		if (is_throwing_error) {
			if (previous_effect === null) {
				is_throwing_error = false;
			}

			if (should_rethrow_error(effect)) {
				throw error;
			}

			return;
		}

		if (previous_effect !== null) {
			is_throwing_error = true;
		}

		propagate_error(error, effect);

		if (should_rethrow_error(effect)) {
			throw error;
		}
	}

	/**
	 * @param {Value} signal
	 * @param {Effect} effect
	 * @param {boolean} [root]
	 */
	function schedule_possible_effect_self_invalidation(signal, effect, root = true) {
		var reactions = signal.reactions;
		if (reactions === null) return;

		for (var i = 0; i < reactions.length; i++) {
			var reaction = reactions[i];

			if (reaction_sources?.includes(signal)) continue;

			if ((reaction.f & DERIVED) !== 0) {
				schedule_possible_effect_self_invalidation(/** @type {Derived} */ (reaction), effect, false);
			} else if (effect === reaction) {
				if (root) {
					set_signal_status(reaction, DIRTY);
				} else if ((reaction.f & CLEAN) !== 0) {
					set_signal_status(reaction, MAYBE_DIRTY);
				}
				schedule_effect(/** @type {Effect} */ (reaction));
			}
		}
	}

	/**
	 * @template V
	 * @param {Reaction} reaction
	 * @returns {V}
	 */
	function update_reaction(reaction) {
		var previous_deps = new_deps;
		var previous_skipped_deps = skipped_deps;
		var previous_untracked_writes = untracked_writes;
		var previous_reaction = active_reaction;
		var previous_skip_reaction = skip_reaction;
		var previous_reaction_sources = reaction_sources;
		var previous_component_context = component_context;
		var previous_untracking = untracking;

		var flags = reaction.f;

		new_deps = /** @type {null | Value[]} */ (null);
		skipped_deps = 0;
		untracked_writes = null;
		skip_reaction =
			(flags & UNOWNED) !== 0 && (untracking || !is_updating_effect || active_reaction === null);
		active_reaction = (flags & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? reaction : null;

		reaction_sources = null;
		set_component_context(reaction.ctx);
		untracking = false;
		read_version++;

		reaction.f |= EFFECT_IS_UPDATING;

		try {
			var result = /** @type {Function} */ (0, reaction.fn)();
			var deps = reaction.deps;

			if (new_deps !== null) {
				var i;

				remove_reactions(reaction, skipped_deps);

				if (deps !== null && skipped_deps > 0) {
					deps.length = skipped_deps + new_deps.length;
					for (i = 0; i < new_deps.length; i++) {
						deps[skipped_deps + i] = new_deps[i];
					}
				} else {
					reaction.deps = deps = new_deps;
				}

				if (!skip_reaction) {
					for (i = skipped_deps; i < deps.length; i++) {
						(deps[i].reactions ??= []).push(reaction);
					}
				}
			} else if (deps !== null && skipped_deps < deps.length) {
				remove_reactions(reaction, skipped_deps);
				deps.length = skipped_deps;
			}

			// If we're inside an effect and we have untracked writes, then we need to
			// ensure that if any of those untracked writes result in re-invalidation
			// of the current effect, then that happens accordingly
			if (
				is_runes() &&
				untracked_writes !== null &&
				!untracking &&
				deps !== null &&
				(reaction.f & (DERIVED | MAYBE_DIRTY | DIRTY)) === 0
			) {
				for (i = 0; i < /** @type {Source[]} */ (untracked_writes).length; i++) {
					schedule_possible_effect_self_invalidation(
						untracked_writes[i],
						/** @type {Effect} */ (reaction)
					);
				}
			}

			// If we are returning to an previous reaction then
			// we need to increment the read version to ensure that
			// any dependencies in this reaction aren't marked with
			// the same version
			if (previous_reaction !== null && previous_reaction !== reaction) {
				read_version++;

				if (untracked_writes !== null) {
					if (previous_untracked_writes === null) {
						previous_untracked_writes = untracked_writes;
					} else {
						previous_untracked_writes.push(.../** @type {Source[]} */ (untracked_writes));
					}
				}
			}

			return result;
		} finally {
			new_deps = previous_deps;
			skipped_deps = previous_skipped_deps;
			untracked_writes = previous_untracked_writes;
			active_reaction = previous_reaction;
			skip_reaction = previous_skip_reaction;
			reaction_sources = previous_reaction_sources;
			set_component_context(previous_component_context);
			untracking = previous_untracking;

			reaction.f ^= EFFECT_IS_UPDATING;
		}
	}

	/**
	 * @template V
	 * @param {Reaction} signal
	 * @param {Value<V>} dependency
	 * @returns {void}
	 */
	function remove_reaction(signal, dependency) {
		let reactions = dependency.reactions;
		if (reactions !== null) {
			var index = index_of.call(reactions, signal);
			if (index !== -1) {
				var new_length = reactions.length - 1;
				if (new_length === 0) {
					reactions = dependency.reactions = null;
				} else {
					// Swap with last element and then remove.
					reactions[index] = reactions[new_length];
					reactions.pop();
				}
			}
		}
		// If the derived has no reactions, then we can disconnect it from the graph,
		// allowing it to either reconnect in the future, or be GC'd by the VM.
		if (
			reactions === null &&
			(dependency.f & DERIVED) !== 0 &&
			// Destroying a child effect while updating a parent effect can cause a dependency to appear
			// to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
			// allows us to skip the expensive work of disconnecting and immediately reconnecting it
			(new_deps === null || !new_deps.includes(dependency))
		) {
			set_signal_status(dependency, MAYBE_DIRTY);
			// If we are working with a derived that is owned by an effect, then mark it as being
			// disconnected.
			if ((dependency.f & (UNOWNED | DISCONNECTED)) === 0) {
				dependency.f ^= DISCONNECTED;
			}
			// Disconnect any reactions owned by this reaction
			destroy_derived_effects(/** @type {Derived} **/ (dependency));
			remove_reactions(/** @type {Derived} **/ (dependency), 0);
		}
	}

	/**
	 * @param {Reaction} signal
	 * @param {number} start_index
	 * @returns {void}
	 */
	function remove_reactions(signal, start_index) {
		var dependencies = signal.deps;
		if (dependencies === null) return;

		for (var i = start_index; i < dependencies.length; i++) {
			remove_reaction(signal, dependencies[i]);
		}
	}

	/**
	 * @param {Effect} effect
	 * @returns {void}
	 */
	function update_effect(effect) {
		var flags = effect.f;

		if ((flags & DESTROYED) !== 0) {
			return;
		}

		set_signal_status(effect, CLEAN);

		var previous_effect = active_effect;
		var previous_component_context = component_context;
		var was_updating_effect = is_updating_effect;

		active_effect = effect;
		is_updating_effect = true;

		try {
			if ((flags & BLOCK_EFFECT) !== 0) {
				destroy_block_effect_children(effect);
			} else {
				destroy_effect_children(effect);
			}

			execute_effect_teardown(effect);
			var teardown = update_reaction(effect);
			effect.teardown = typeof teardown === 'function' ? teardown : null;
			effect.wv = write_version;

			var deps = effect.deps;

			// In DEV, we need to handle a case where $inspect.trace() might
			// incorrectly state a source dependency has not changed when it has.
			// That's beacuse that source was changed by the same effect, causing
			// the versions to match. We can avoid this by incrementing the version
			var dep; if (DEV && tracing_mode_flag && (effect.f & DIRTY) !== 0 && deps !== null) ;

			if (DEV) ;
		} catch (error) {
			handle_error(error, effect, previous_effect, previous_component_context || effect.ctx);
		} finally {
			is_updating_effect = was_updating_effect;
			active_effect = previous_effect;
		}
	}

	function infinite_loop_guard() {
		try {
			effect_update_depth_exceeded();
		} catch (error) {
			// Try and handle the error so it can be caught at a boundary, that's
			// if there's an effect available from when it was last scheduled
			if (last_scheduled_effect !== null) {
				{
					handle_error(error, last_scheduled_effect, null);
				}
			} else {
				throw error;
			}
		}
	}

	function flush_queued_root_effects() {
		var was_updating_effect = is_updating_effect;

		try {
			var flush_count = 0;
			is_updating_effect = true;

			while (queued_root_effects.length > 0) {
				if (flush_count++ > 1000) {
					infinite_loop_guard();
				}

				var root_effects = queued_root_effects;
				var length = root_effects.length;

				queued_root_effects = [];

				for (var i = 0; i < length; i++) {
					var collected_effects = process_effects(root_effects[i]);
					flush_queued_effects(collected_effects);
				}
				old_values.clear();
			}
		} finally {
			is_flushing = false;
			is_updating_effect = was_updating_effect;

			last_scheduled_effect = null;
		}
	}

	/**
	 * @param {Array<Effect>} effects
	 * @returns {void}
	 */
	function flush_queued_effects(effects) {
		var length = effects.length;
		if (length === 0) return;

		for (var i = 0; i < length; i++) {
			var effect = effects[i];

			if ((effect.f & (DESTROYED | INERT)) === 0) {
				try {
					if (check_dirtiness(effect)) {
						update_effect(effect);

						// Effects with no dependencies or teardown do not get added to the effect tree.
						// Deferred effects (e.g. `$effect(...)`) _are_ added to the tree because we
						// don't know if we need to keep them until they are executed. Doing the check
						// here (rather than in `update_effect`) allows us to skip the work for
						// immediate effects.
						if (effect.deps === null && effect.first === null && effect.nodes_start === null) {
							if (effect.teardown === null) {
								// remove this effect from the graph
								unlink_effect(effect);
							} else {
								// keep the effect in the graph, but free up some memory
								effect.fn = null;
							}
						}
					}
				} catch (error) {
					handle_error(error, effect, null, effect.ctx);
				}
			}
		}
	}

	/**
	 * @param {Effect} signal
	 * @returns {void}
	 */
	function schedule_effect(signal) {
		if (!is_flushing) {
			is_flushing = true;
			queueMicrotask(flush_queued_root_effects);
		}

		var effect = (last_scheduled_effect = signal);

		while (effect.parent !== null) {
			effect = effect.parent;
			var flags = effect.f;

			if ((flags & (ROOT_EFFECT | BRANCH_EFFECT)) !== 0) {
				if ((flags & CLEAN) === 0) return;
				effect.f ^= CLEAN;
			}
		}

		queued_root_effects.push(effect);
	}

	/**
	 *
	 * This function both runs render effects and collects user effects in topological order
	 * from the starting effect passed in. Effects will be collected when they match the filtered
	 * bitwise flag passed in only. The collected effects array will be populated with all the user
	 * effects to be flushed.
	 *
	 * @param {Effect} root
	 * @returns {Effect[]}
	 */
	function process_effects(root) {
		/** @type {Effect[]} */
		var effects = [];

		/** @type {Effect | null} */
		var effect = root;

		while (effect !== null) {
			var flags = effect.f;
			var is_branch = (flags & (BRANCH_EFFECT | ROOT_EFFECT)) !== 0;
			var is_skippable_branch = is_branch && (flags & CLEAN) !== 0;

			if (!is_skippable_branch && (flags & INERT) === 0) {
				if ((flags & EFFECT) !== 0) {
					effects.push(effect);
				} else if (is_branch) {
					effect.f ^= CLEAN;
				} else {
					try {
						if (check_dirtiness(effect)) {
							update_effect(effect);
						}
					} catch (error) {
						handle_error(error, effect, null, effect.ctx);
					}
				}

				/** @type {Effect | null} */
				var child = effect.first;

				if (child !== null) {
					effect = child;
					continue;
				}
			}

			var parent = effect.parent;
			effect = effect.next;

			while (effect === null && parent !== null) {
				effect = parent.next;
				parent = parent.parent;
			}
		}

		return effects;
	}

	/**
	 * Synchronously flush any pending updates.
	 * Returns void if no callback is provided, otherwise returns the result of calling the callback.
	 * @template [T=void]
	 * @param {(() => T) | undefined} [fn]
	 * @returns {T}
	 */
	function flushSync(fn) {
		var result;

		while (true) {
			flush_tasks();

			if (queued_root_effects.length === 0) {
				return /** @type {T} */ (result);
			}

			is_flushing = true;
			flush_queued_root_effects();
		}
	}

	/**
	 * Returns a promise that resolves once any pending state changes have been applied.
	 * @returns {Promise<void>}
	 */
	async function tick() {
		await Promise.resolve();
		// By calling flushSync we guarantee that any pending state changes are applied after one tick.
		// TODO look into whether we can make flushing subsequent updates synchronously in the future.
		flushSync();
	}

	/**
	 * @template V
	 * @param {Value<V>} signal
	 * @returns {V}
	 */
	function get(signal) {
		var flags = signal.f;
		var is_derived = (flags & DERIVED) !== 0;

		// Register the dependency on the current reaction signal.
		if (active_reaction !== null && !untracking) {
			if (!reaction_sources?.includes(signal)) {
				var deps = active_reaction.deps;
				if (signal.rv < read_version) {
					signal.rv = read_version;
					// If the signal is accessing the same dependencies in the same
					// order as it did last time, increment `skipped_deps`
					// rather than updating `new_deps`, which creates GC cost
					if (new_deps === null && deps !== null && deps[skipped_deps] === signal) {
						skipped_deps++;
					} else if (new_deps === null) {
						new_deps = [signal];
					} else if (!skip_reaction || !new_deps.includes(signal)) {
						// Normally we can push duplicated dependencies to `new_deps`, but if we're inside
						// an unowned derived because skip_reaction is true, then we need to ensure that
						// we don't have duplicates
						new_deps.push(signal);
					}
				}
			}
		} else if (
			is_derived &&
			/** @type {Derived} */ (signal).deps === null &&
			/** @type {Derived} */ (signal).effects === null
		) {
			var derived = /** @type {Derived} */ (signal);
			var parent = derived.parent;

			if (parent !== null && (parent.f & UNOWNED) === 0) {
				// If the derived is owned by another derived then mark it as unowned
				// as the derived value might have been referenced in a different context
				// since and thus its parent might not be its true owner anymore
				derived.f ^= UNOWNED;
			}
		}

		if (is_derived) {
			derived = /** @type {Derived} */ (signal);

			if (check_dirtiness(derived)) {
				update_derived(derived);
			}
		}

		if (is_destroying_effect && old_values.has(signal)) {
			return old_values.get(signal);
		}

		return signal.v;
	}

	/**
	 * When used inside a [`$derived`](https://svelte.dev/docs/svelte/$derived) or [`$effect`](https://svelte.dev/docs/svelte/$effect),
	 * any state read inside `fn` will not be treated as a dependency.
	 *
	 * ```ts
	 * $effect(() => {
	 *   // this will run when `data` changes, but not when `time` changes
	 *   save(data, {
	 *     timestamp: untrack(() => time)
	 *   });
	 * });
	 * ```
	 * @template T
	 * @param {() => T} fn
	 * @returns {T}
	 */
	function untrack(fn) {
		var previous_untracking = untracking;
		try {
			untracking = true;
			return fn();
		} finally {
			untracking = previous_untracking;
		}
	}

	const STATUS_MASK = -7169;

	/**
	 * @param {Signal} signal
	 * @param {number} status
	 * @returns {void}
	 */
	function set_signal_status(signal, status) {
		signal.f = (signal.f & STATUS_MASK) | status;
	}

	/** @import { Derived, Effect, Source, Value } from '#client' */
	const old_values = new Map();

	/**
	 * @template V
	 * @param {V} v
	 * @param {Error | null} [stack]
	 * @returns {Source<V>}
	 */
	// TODO rename this to `state` throughout the codebase
	function source(v, stack) {
		/** @type {Value} */
		var signal = {
			f: 0, // TODO ideally we could skip this altogether, but it causes type errors
			v,
			reactions: null,
			equals,
			rv: 0,
			wv: 0
		};

		return signal;
	}

	/**
	 * @template V
	 * @param {V} v
	 * @param {Error | null} [stack]
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function state(v, stack) {
		const s = source(v);

		push_reaction_value(s);

		return s;
	}

	/**
	 * @template V
	 * @param {V} initial_value
	 * @param {boolean} [immutable]
	 * @returns {Source<V>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function mutable_source(initial_value, immutable = false) {
		const s = source(initial_value);
		if (!immutable) {
			s.equals = safe_equals;
		}

		return s;
	}

	/**
	 * @template V
	 * @param {Source<V>} source
	 * @param {V} value
	 * @param {boolean} [should_proxy]
	 * @returns {V}
	 */
	function set(source, value, should_proxy = false) {
		if (
			active_reaction !== null &&
			!untracking &&
			is_runes() &&
			(active_reaction.f & (DERIVED | BLOCK_EFFECT)) !== 0 &&
			!reaction_sources?.includes(source)
		) {
			state_unsafe_mutation();
		}

		let new_value = should_proxy ? proxy(value) : value;

		return internal_set(source, new_value);
	}

	/**
	 * @template V
	 * @param {Source<V>} source
	 * @param {V} value
	 * @returns {V}
	 */
	function internal_set(source, value) {
		if (!source.equals(value)) {
			var old_value = source.v;

			if (is_destroying_effect) {
				old_values.set(source, value);
			} else {
				old_values.set(source, old_value);
			}

			source.v = value;

			if ((source.f & DERIVED) !== 0) {
				// if we are assigning to a dirty derived we set it to clean/maybe dirty but we also eagerly execute it to track the dependencies
				if ((source.f & DIRTY) !== 0) {
					execute_derived(/** @type {Derived} */ (source));
				}
				set_signal_status(source, (source.f & UNOWNED) === 0 ? CLEAN : MAYBE_DIRTY);
			}

			source.wv = increment_write_version();

			mark_reactions(source, DIRTY);

			// It's possible that the current reaction might not have up-to-date dependencies
			// whilst it's actively running. So in the case of ensuring it registers the reaction
			// properly for itself, we need to ensure the current effect actually gets
			// scheduled. i.e: `$effect(() => x++)`
			if (
				active_effect !== null &&
				(active_effect.f & CLEAN) !== 0 &&
				(active_effect.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0
			) {
				if (untracked_writes === null) {
					set_untracked_writes([source]);
				} else {
					untracked_writes.push(source);
				}
			}
		}

		return value;
	}

	/**
	 * @param {Value} signal
	 * @param {number} status should be DIRTY or MAYBE_DIRTY
	 * @returns {void}
	 */
	function mark_reactions(signal, status) {
		var reactions = signal.reactions;
		if (reactions === null) return;
		var length = reactions.length;

		for (var i = 0; i < length; i++) {
			var reaction = reactions[i];
			var flags = reaction.f;

			// Skip any effects that are already dirty
			if ((flags & DIRTY) !== 0) continue;

			set_signal_status(reaction, status);

			// If the signal a) was previously clean or b) is an unowned derived, then mark it
			if ((flags & (CLEAN | UNOWNED)) !== 0) {
				if ((flags & DERIVED) !== 0) {
					mark_reactions(/** @type {Derived} */ (reaction), MAYBE_DIRTY);
				} else {
					schedule_effect(/** @type {Effect} */ (reaction));
				}
			}
		}
	}

	/** @import { ComponentContext } from '#client' */


	/** @type {ComponentContext | null} */
	let component_context = null;

	/** @param {ComponentContext | null} context */
	function set_component_context(context) {
		component_context = context;
	}

	/**
	 * The current component function. Different from current component context:
	 * ```html
	 * <!-- App.svelte -->
	 * <Foo>
	 *   <Bar /> <!-- context == Foo.svelte, function == App.svelte -->
	 * </Foo>
	 * ```
	 * @type {ComponentContext['function']}
	 */
	let dev_current_component_function = null;

	/** @param {ComponentContext['function']} fn */
	function set_dev_current_component_function(fn) {
		dev_current_component_function = fn;
	}

	/**
	 * Associates an arbitrary `context` object with the current component and the specified `key`
	 * and returns that object. The context is then available to children of the component
	 * (including slotted content) with `getContext`.
	 *
	 * Like lifecycle functions, this must be called during component initialisation.
	 *
	 * @template T
	 * @param {any} key
	 * @param {T} context
	 * @returns {T}
	 */
	function setContext(key, context) {
		const context_map = get_or_init_context_map();
		context_map.set(key, context);
		return context;
	}

	/**
	 * @param {Record<string, unknown>} props
	 * @param {any} runes
	 * @param {Function} [fn]
	 * @returns {void}
	 */
	function push(props, runes = false, fn) {
		var ctx = (component_context = {
			p: component_context,
			c: null,
			d: false,
			e: null,
			m: false,
			s: props,
			x: null,
			l: null
		});

		teardown(() => {
			/** @type {ComponentContext} */ (ctx).d = true;
		});
	}

	/**
	 * @template {Record<string, any>} T
	 * @param {T} [component]
	 * @returns {T}
	 */
	function pop(component) {
		const context_stack_item = component_context;
		if (context_stack_item !== null) {
			if (component !== undefined) {
				context_stack_item.x = component;
			}
			const component_effects = context_stack_item.e;
			if (component_effects !== null) {
				var previous_effect = active_effect;
				var previous_reaction = active_reaction;
				context_stack_item.e = null;
				try {
					for (var i = 0; i < component_effects.length; i++) {
						var component_effect = component_effects[i];
						set_active_effect(component_effect.effect);
						set_active_reaction(component_effect.reaction);
						effect(component_effect.fn);
					}
				} finally {
					set_active_effect(previous_effect);
					set_active_reaction(previous_reaction);
				}
			}
			component_context = context_stack_item.p;
			context_stack_item.m = true;
		}
		// Micro-optimization: Don't set .a above to the empty object
		// so it can be garbage-collected when the return here is unused
		return component || /** @type {T} */ ({});
	}

	/** @returns {boolean} */
	function is_runes() {
		return true;
	}

	/**
	 * @param {string} name
	 * @returns {Map<unknown, unknown>}
	 */
	function get_or_init_context_map(name) {
		if (component_context === null) {
			lifecycle_outside_component();
		}

		return (component_context.c ??= new Map(get_parent_context(component_context) || undefined));
	}

	/**
	 * @param {ComponentContext} component_context
	 * @returns {Map<unknown, unknown> | null}
	 */
	function get_parent_context(component_context) {
		let parent = component_context.p;
		while (parent !== null) {
			const context_map = parent.c;
			if (context_map !== null) {
				return context_map;
			}
			parent = parent.p;
		}
		return null;
	}

	const VOID_ELEMENT_NAMES = [
		'area',
		'base',
		'br',
		'col',
		'command',
		'embed',
		'hr',
		'img',
		'input',
		'keygen',
		'link',
		'meta',
		'param',
		'source',
		'track',
		'wbr'
	];

	/**
	 * Returns `true` if `name` is of a void element
	 * @param {string} name
	 */
	function is_void(name) {
		return VOID_ELEMENT_NAMES.includes(name) || name.toLowerCase() === '!doctype';
	}

	/**
	 * @param {string} name
	 */
	function is_capture_event(name) {
		return name.endsWith('capture') && name !== 'gotpointercapture' && name !== 'lostpointercapture';
	}

	/** List of Element events that will be delegated */
	const DELEGATED_EVENTS = [
		'beforeinput',
		'click',
		'change',
		'dblclick',
		'contextmenu',
		'focusin',
		'focusout',
		'input',
		'keydown',
		'keyup',
		'mousedown',
		'mousemove',
		'mouseout',
		'mouseover',
		'mouseup',
		'pointerdown',
		'pointermove',
		'pointerout',
		'pointerover',
		'pointerup',
		'touchend',
		'touchmove',
		'touchstart'
	];

	/**
	 * Returns `true` if `event_name` is a delegated event
	 * @param {string} event_name
	 */
	function is_delegated(event_name) {
		return DELEGATED_EVENTS.includes(event_name);
	}

	/**
	 * @type {Record<string, string>}
	 * List of attribute names that should be aliased to their property names
	 * because they behave differently between setting them as an attribute and
	 * setting them as a property.
	 */
	const ATTRIBUTE_ALIASES = {
		// no `class: 'className'` because we handle that separately
		formnovalidate: 'formNoValidate',
		ismap: 'isMap',
		nomodule: 'noModule',
		playsinline: 'playsInline',
		readonly: 'readOnly',
		defaultvalue: 'defaultValue',
		defaultchecked: 'defaultChecked',
		srcobject: 'srcObject',
		novalidate: 'noValidate',
		allowfullscreen: 'allowFullscreen',
		disablepictureinpicture: 'disablePictureInPicture',
		disableremoteplayback: 'disableRemotePlayback'
	};

	/**
	 * @param {string} name
	 */
	function normalize_attribute(name) {
		name = name.toLowerCase();
		return ATTRIBUTE_ALIASES[name] ?? name;
	}

	/**
	 * Subset of delegated events which should be passive by default.
	 * These two are already passive via browser defaults on window, document and body.
	 * But since
	 * - we're delegating them
	 * - they happen often
	 * - they apply to mobile which is generally less performant
	 * we're marking them as passive by default for other elements, too.
	 */
	const PASSIVE_EVENTS = ['touchstart', 'touchmove'];

	/**
	 * Returns `true` if `name` is a passive event
	 * @param {string} name
	 */
	function is_passive_event(name) {
		return PASSIVE_EVENTS.includes(name);
	}

	/** List of elements that require raw contents and should not have SSR comments put in them */
	const RAW_TEXT_ELEMENTS = /** @type {const} */ (['textarea', 'script', 'style', 'title']);

	/** @param {string} name */
	function is_raw_text_element(name) {
		return RAW_TEXT_ELEMENTS.includes(/** @type {RAW_TEXT_ELEMENTS[number]} */ (name));
	}

	/**
	 * Prevent devtools trying to make `location` a clickable link by inserting a zero-width space
	 * @template {string | undefined} T
	 * @param {T} location
	 * @returns {T};
	 */
	function sanitize_location(location) {
		return /** @type {T} */ (location?.replace(/\//g, '/\u200b'));
	}

	/** @import { SourceLocation } from '#shared' */

	/**
	 * @param {any} fn
	 * @param {string} filename
	 * @param {SourceLocation[]} locations
	 * @returns {any}
	 */
	function add_locations(fn, filename, locations) {
		return (/** @type {any[]} */ ...args) => {
			const dom = fn(...args);

			var node = hydrating ? dom : dom.nodeType === 11 ? dom.firstChild : dom;
			assign_locations(node, filename, locations);

			return dom;
		};
	}

	/**
	 * @param {Element} element
	 * @param {string} filename
	 * @param {SourceLocation} location
	 */
	function assign_location(element, filename, location) {
		// @ts-expect-error
		element.__svelte_meta = {
			loc: { file: filename, line: location[0], column: location[1] }
		};

		if (location[2]) {
			assign_locations(element.firstChild, filename, location[2]);
		}
	}

	/**
	 * @param {Node | null} node
	 * @param {string} filename
	 * @param {SourceLocation[]} locations
	 */
	function assign_locations(node, filename, locations) {
		var i = 0;
		var depth = 0;

		while (node && i < locations.length) {
			if (hydrating && node.nodeType === 8) {
				var comment = /** @type {Comment} */ (node);
				if (comment.data === HYDRATION_START || comment.data === HYDRATION_START_ELSE) depth += 1;
				else if (comment.data[0] === HYDRATION_END) depth -= 1;
			}

			if (depth === 0 && node.nodeType === 1) {
				assign_location(/** @type {Element} */ (node), filename, locations[i++]);
			}

			node = node.nextSibling;
		}
	}

	/**
	 * @param {HTMLElement} dom
	 * @param {boolean} value
	 * @returns {void}
	 */
	function autofocus(dom, value) {
		if (value) {
			const body = document.body;
			dom.autofocus = true;

			queue_micro_task(() => {
				if (document.activeElement === body) {
					dom.focus();
				}
			});
		}
	}

	let listening_to_form_reset = false;

	function add_form_reset_listener() {
		if (!listening_to_form_reset) {
			listening_to_form_reset = true;
			document.addEventListener(
				'reset',
				(evt) => {
					// Needs to happen one tick later or else the dom properties of the form
					// elements have not updated to their reset values yet
					Promise.resolve().then(() => {
						if (!evt.defaultPrevented) {
							for (const e of /**@type {HTMLFormElement} */ (evt.target).elements) {
								// @ts-expect-error
								e.__on_r?.();
							}
						}
					});
				},
				// In the capture phase to guarantee we get noticed of it (no possiblity of stopPropagation)
				{ capture: true }
			);
		}
	}

	/**
	 * @template T
	 * @param {() => T} fn
	 */
	function without_reactive_context(fn) {
		var previous_reaction = active_reaction;
		var previous_effect = active_effect;
		set_active_reaction(null);
		set_active_effect(null);
		try {
			return fn();
		} finally {
			set_active_reaction(previous_reaction);
			set_active_effect(previous_effect);
		}
	}

	/**
	 * Listen to the given event, and then instantiate a global form reset listener if not already done,
	 * to notify all bindings when the form is reset
	 * @param {HTMLElement} element
	 * @param {string} event
	 * @param {(is_reset?: true) => void} handler
	 * @param {(is_reset?: true) => void} [on_reset]
	 */
	function listen_to_event_and_reset_event(element, event, handler, on_reset = handler) {
		element.addEventListener(event, () => without_reactive_context(handler));
		// @ts-expect-error
		const prev = element.__on_r;
		if (prev) {
			// special case for checkbox that can have multiple binds (group & checked)
			// @ts-expect-error
			element.__on_r = () => {
				prev();
				on_reset(true);
			};
		} else {
			// @ts-expect-error
			element.__on_r = () => on_reset(true);
		}

		add_form_reset_listener();
	}

	/** @type {Set<string>} */
	const all_registered_events = new Set();

	/** @type {Set<(events: Array<string>) => void>} */
	const root_event_handles = new Set();

	/**
	 * @param {string} event_name
	 * @param {EventTarget} dom
	 * @param {EventListener} [handler]
	 * @param {AddEventListenerOptions} [options]
	 */
	function create_event(event_name, dom, handler, options = {}) {
		/**
		 * @this {EventTarget}
		 */
		function target_handler(/** @type {Event} */ event) {
			if (!options.capture) {
				// Only call in the bubble phase, else delegated events would be called before the capturing events
				handle_event_propagation.call(dom, event);
			}
			if (!event.cancelBubble) {
				return without_reactive_context(() => {
					return handler?.call(this, event);
				});
			}
		}

		// Chrome has a bug where pointer events don't work when attached to a DOM element that has been cloned
		// with cloneNode() and the DOM element is disconnected from the document. To ensure the event works, we
		// defer the attachment till after it's been appended to the document. TODO: remove this once Chrome fixes
		// this bug. The same applies to wheel events and touch events.
		if (
			event_name.startsWith('pointer') ||
			event_name.startsWith('touch') ||
			event_name === 'wheel'
		) {
			queue_micro_task(() => {
				dom.addEventListener(event_name, target_handler, options);
			});
		} else {
			dom.addEventListener(event_name, target_handler, options);
		}

		return target_handler;
	}

	/**
	 * @param {string} event_name
	 * @param {Element} dom
	 * @param {EventListener} [handler]
	 * @param {boolean} [capture]
	 * @param {boolean} [passive]
	 * @returns {void}
	 */
	function event(event_name, dom, handler, capture, passive) {
		var options = { capture, passive };
		var target_handler = create_event(event_name, dom, handler, options);

		// @ts-ignore
		if (dom === document.body || dom === window || dom === document) {
			teardown(() => {
				dom.removeEventListener(event_name, target_handler, options);
			});
		}
	}

	/**
	 * @param {Array<string>} events
	 * @returns {void}
	 */
	function delegate(events) {
		for (var i = 0; i < events.length; i++) {
			all_registered_events.add(events[i]);
		}

		for (var fn of root_event_handles) {
			fn(events);
		}
	}

	/**
	 * @this {EventTarget}
	 * @param {Event} event
	 * @returns {void}
	 */
	function handle_event_propagation(event) {
		var handler_element = this;
		var owner_document = /** @type {Node} */ (handler_element).ownerDocument;
		var event_name = event.type;
		var path = event.composedPath?.() || [];
		var current_target = /** @type {null | Element} */ (path[0] || event.target);

		// composedPath contains list of nodes the event has propagated through.
		// We check __root to skip all nodes below it in case this is a
		// parent of the __root node, which indicates that there's nested
		// mounted apps. In this case we don't want to trigger events multiple times.
		var path_idx = 0;

		// @ts-expect-error is added below
		var handled_at = event.__root;

		if (handled_at) {
			var at_idx = path.indexOf(handled_at);
			if (
				at_idx !== -1 &&
				(handler_element === document || handler_element === /** @type {any} */ (window))
			) {
				// This is the fallback document listener or a window listener, but the event was already handled
				// -> ignore, but set handle_at to document/window so that we're resetting the event
				// chain in case someone manually dispatches the same event object again.
				// @ts-expect-error
				event.__root = handler_element;
				return;
			}

			// We're deliberately not skipping if the index is higher, because
			// someone could create an event programmatically and emit it multiple times,
			// in which case we want to handle the whole propagation chain properly each time.
			// (this will only be a false negative if the event is dispatched multiple times and
			// the fallback document listener isn't reached in between, but that's super rare)
			var handler_idx = path.indexOf(handler_element);
			if (handler_idx === -1) {
				// handle_idx can theoretically be -1 (happened in some JSDOM testing scenarios with an event listener on the window object)
				// so guard against that, too, and assume that everything was handled at this point.
				return;
			}

			if (at_idx <= handler_idx) {
				path_idx = at_idx;
			}
		}

		current_target = /** @type {Element} */ (path[path_idx] || event.target);
		// there can only be one delegated event per element, and we either already handled the current target,
		// or this is the very first target in the chain which has a non-delegated listener, in which case it's safe
		// to handle a possible delegated event on it later (through the root delegation listener for example).
		if (current_target === handler_element) return;

		// Proxy currentTarget to correct target
		define_property(event, 'currentTarget', {
			configurable: true,
			get() {
				return current_target || owner_document;
			}
		});

		// This started because of Chromium issue https://chromestatus.com/feature/5128696823545856,
		// where removal or moving of of the DOM can cause sync `blur` events to fire, which can cause logic
		// to run inside the current `active_reaction`, which isn't what we want at all. However, on reflection,
		// it's probably best that all event handled by Svelte have this behaviour, as we don't really want
		// an event handler to run in the context of another reaction or effect.
		var previous_reaction = active_reaction;
		var previous_effect = active_effect;
		set_active_reaction(null);
		set_active_effect(null);

		try {
			/**
			 * @type {unknown}
			 */
			var throw_error;
			/**
			 * @type {unknown[]}
			 */
			var other_errors = [];

			while (current_target !== null) {
				/** @type {null | Element} */
				var parent_element =
					current_target.assignedSlot ||
					current_target.parentNode ||
					/** @type {any} */ (current_target).host ||
					null;

				try {
					// @ts-expect-error
					var delegated = current_target['__' + event_name];

					if (
						delegated != null &&
						(!(/** @type {any} */ (current_target).disabled) ||
							// DOM could've been updated already by the time this is reached, so we check this as well
							// -> the target could not have been disabled because it emits the event in the first place
							event.target === current_target)
					) {
						if (is_array(delegated)) {
							var [fn, ...data] = delegated;
							fn.apply(current_target, [event, ...data]);
						} else {
							delegated.call(current_target, event);
						}
					}
				} catch (error) {
					if (throw_error) {
						other_errors.push(error);
					} else {
						throw_error = error;
					}
				}
				if (event.cancelBubble || parent_element === handler_element || parent_element === null) {
					break;
				}
				current_target = parent_element;
			}

			if (throw_error) {
				for (let error of other_errors) {
					// Throw the rest of the errors, one-by-one on a microtask
					queueMicrotask(() => {
						throw error;
					});
				}
				throw throw_error;
			}
		} finally {
			// @ts-expect-error is used above
			event.__root = handler_element;
			// @ts-ignore remove proxy on currentTarget
			delete event.currentTarget;
			set_active_reaction(previous_reaction);
			set_active_effect(previous_effect);
		}
	}

	/**
	 * In dev, warn if an event handler is not a function, as it means the
	 * user probably called the handler or forgot to add a `() =>`
	 * @param {() => (event: Event, ...args: any) => void} thunk
	 * @param {EventTarget} element
	 * @param {[Event, ...any]} args
	 * @param {any} component
	 * @param {[number, number]} [loc]
	 * @param {boolean} [remove_parens]
	 */
	function apply(
		thunk,
		element,
		args,
		component,
		loc,
		has_side_effects = false,
		remove_parens = false
	) {
		let handler;
		let error;

		try {
			handler = thunk();
		} catch (e) {
			error = e;
		}

		if (typeof handler !== 'function' && (has_side_effects || handler != null || error)) {
			component?.[FILENAME];
			const phase = args[0]?.eventPhase < Event.BUBBLING_PHASE ? 'capture' : '';
			args[0]?.type + phase;

			event_handler_invalid();

			if (error) {
				throw error;
			}
		}
		handler?.apply(element, args);
	}

	/** @param {string} html */
	function create_fragment_from_html(html) {
		var elem = document.createElement('template');
		elem.innerHTML = html;
		return elem.content;
	}

	/** @import { Effect, TemplateNode } from '#client' */

	/**
	 * @param {TemplateNode} start
	 * @param {TemplateNode | null} end
	 */
	function assign_nodes(start, end) {
		var effect = /** @type {Effect} */ (active_effect);
		if (effect.nodes_start === null) {
			effect.nodes_start = start;
			effect.nodes_end = end;
		}
	}

	/**
	 * @param {string} content
	 * @param {number} flags
	 * @returns {() => Node | Node[]}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function template(content, flags) {
		var is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;
		var use_import_node = (flags & TEMPLATE_USE_IMPORT_NODE) !== 0;

		/** @type {Node} */
		var node;

		/**
		 * Whether or not the first item is a text/element node. If not, we need to
		 * create an additional comment node to act as `effect.nodes.start`
		 */
		var has_start = !content.startsWith('<!>');

		return () => {
			if (hydrating) {
				assign_nodes(hydrate_node, null);
				return hydrate_node;
			}

			if (node === undefined) {
				node = create_fragment_from_html(has_start ? content : '<!>' + content);
				if (!is_fragment) node = /** @type {Node} */ (get_first_child(node));
			}

			var clone = /** @type {TemplateNode} */ (
				use_import_node || is_firefox ? document.importNode(node, true) : node.cloneNode(true)
			);

			if (is_fragment) {
				var start = /** @type {TemplateNode} */ (get_first_child(clone));
				var end = /** @type {TemplateNode} */ (clone.lastChild);

				assign_nodes(start, end);
			} else {
				assign_nodes(clone, clone);
			}

			return clone;
		};
	}

	function comment() {
		// we're not delegating to `template` here for performance reasons
		if (hydrating) {
			assign_nodes(hydrate_node, null);
			return hydrate_node;
		}

		var frag = document.createDocumentFragment();
		var start = document.createComment('');
		var anchor = create_text();
		frag.append(start, anchor);

		assign_nodes(start, anchor);

		return frag;
	}

	/**
	 * Assign the created (or in hydration mode, traversed) dom elements to the current block
	 * and insert the elements into the dom (in client mode).
	 * @param {Text | Comment | Element} anchor
	 * @param {DocumentFragment | Element} dom
	 */
	function append(anchor, dom) {
		if (hydrating) {
			/** @type {Effect} */ (active_effect).nodes_end = hydrate_node;
			hydrate_next();
			return;
		}

		if (anchor === null) {
			// edge case — void `<svelte:element>` with content
			return;
		}

		anchor.before(/** @type {Node} */ (dom));
	}

	/** @import { ComponentContext, Effect, TemplateNode } from '#client' */
	/** @import { Component, ComponentType, SvelteComponent, MountOptions } from '../../index.js' */

	/**
	 * @param {Element} text
	 * @param {string} value
	 * @returns {void}
	 */
	function set_text(text, value) {
		// For objects, we apply string coercion (which might make things like $state array references in the template reactive) before diffing
		var str = value == null ? '' : typeof value === 'object' ? value + '' : value;
		// @ts-expect-error
		if (str !== (text.__t ??= text.nodeValue)) {
			// @ts-expect-error
			text.__t = str;
			text.nodeValue = str + '';
		}
	}

	/**
	 * Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component.
	 * Transitions will play during the initial render unless the `intro` option is set to `false`.
	 *
	 * @template {Record<string, any>} Props
	 * @template {Record<string, any>} Exports
	 * @param {ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>} component
	 * @param {MountOptions<Props>} options
	 * @returns {Exports}
	 */
	function mount(component, options) {
		return _mount(component, options);
	}

	/**
	 * Hydrates a component on the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component
	 *
	 * @template {Record<string, any>} Props
	 * @template {Record<string, any>} Exports
	 * @param {ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>} component
	 * @param {{} extends Props ? {
	 * 		target: Document | Element | ShadowRoot;
	 * 		props?: Props;
	 * 		events?: Record<string, (e: any) => any>;
	 *  	context?: Map<any, any>;
	 * 		intro?: boolean;
	 * 		recover?: boolean;
	 * 	} : {
	 * 		target: Document | Element | ShadowRoot;
	 * 		props: Props;
	 * 		events?: Record<string, (e: any) => any>;
	 *  	context?: Map<any, any>;
	 * 		intro?: boolean;
	 * 		recover?: boolean;
	 * 	}} options
	 * @returns {Exports}
	 */
	function hydrate(component, options) {
		init_operations();
		options.intro = options.intro ?? false;
		const target = options.target;
		const was_hydrating = hydrating;
		const previous_hydrate_node = hydrate_node;

		try {
			var anchor = /** @type {TemplateNode} */ (get_first_child(target));
			while (
				anchor &&
				(anchor.nodeType !== 8 || /** @type {Comment} */ (anchor).data !== HYDRATION_START)
			) {
				anchor = /** @type {TemplateNode} */ (get_next_sibling(anchor));
			}

			if (!anchor) {
				throw HYDRATION_ERROR;
			}

			set_hydrating(true);
			set_hydrate_node(/** @type {Comment} */ (anchor));
			hydrate_next();

			const instance = _mount(component, { ...options, anchor });

			if (
				hydrate_node === null ||
				hydrate_node.nodeType !== 8 ||
				/** @type {Comment} */ (hydrate_node).data !== HYDRATION_END
			) {
				hydration_mismatch();
				throw HYDRATION_ERROR;
			}

			set_hydrating(false);

			return /**  @type {Exports} */ (instance);
		} catch (error) {
			if (error === HYDRATION_ERROR) {
				if (options.recover === false) {
					hydration_failed();
				}

				// If an error occured above, the operations might not yet have been initialised.
				init_operations();
				clear_text_content(target);

				set_hydrating(false);
				return mount(component, options);
			}

			throw error;
		} finally {
			set_hydrating(was_hydrating);
			set_hydrate_node(previous_hydrate_node);
		}
	}

	/** @type {Map<string, number>} */
	const document_listeners = new Map();

	/**
	 * @template {Record<string, any>} Exports
	 * @param {ComponentType<SvelteComponent<any>> | Component<any>} Component
	 * @param {MountOptions} options
	 * @returns {Exports}
	 */
	function _mount(Component, { target, anchor, props = {}, events, context, intro = true }) {
		init_operations();

		var registered_events = new Set();

		/** @param {Array<string>} events */
		var event_handle = (events) => {
			for (var i = 0; i < events.length; i++) {
				var event_name = events[i];

				if (registered_events.has(event_name)) continue;
				registered_events.add(event_name);

				var passive = is_passive_event(event_name);

				// Add the event listener to both the container and the document.
				// The container listener ensures we catch events from within in case
				// the outer content stops propagation of the event.
				target.addEventListener(event_name, handle_event_propagation, { passive });

				var n = document_listeners.get(event_name);

				if (n === undefined) {
					// The document listener ensures we catch events that originate from elements that were
					// manually moved outside of the container (e.g. via manual portals).
					document.addEventListener(event_name, handle_event_propagation, { passive });
					document_listeners.set(event_name, 1);
				} else {
					document_listeners.set(event_name, n + 1);
				}
			}
		};

		event_handle(array_from(all_registered_events));
		root_event_handles.add(event_handle);

		/** @type {Exports} */
		// @ts-expect-error will be defined because the render effect runs synchronously
		var component = undefined;

		var unmount = component_root(() => {
			var anchor_node = anchor ?? target.appendChild(create_text());

			branch(() => {
				if (context) {
					push({});
					var ctx = /** @type {ComponentContext} */ (component_context);
					ctx.c = context;
				}

				if (events) {
					// We can't spread the object or else we'd lose the state proxy stuff, if it is one
					/** @type {any} */ (props).$$events = events;
				}

				if (hydrating) {
					assign_nodes(/** @type {TemplateNode} */ (anchor_node), null);
				}
				// @ts-expect-error the public typings are not what the actual function looks like
				component = Component(anchor_node, props) || {};

				if (hydrating) {
					/** @type {Effect} */ (active_effect).nodes_end = hydrate_node;
				}

				if (context) {
					pop();
				}
			});

			return () => {
				for (var event_name of registered_events) {
					target.removeEventListener(event_name, handle_event_propagation);

					var n = /** @type {number} */ (document_listeners.get(event_name));

					if (--n === 0) {
						document.removeEventListener(event_name, handle_event_propagation);
						document_listeners.delete(event_name);
					} else {
						document_listeners.set(event_name, n);
					}
				}

				root_event_handles.delete(event_handle);

				if (anchor_node !== anchor) {
					anchor_node.parentNode?.removeChild(anchor_node);
				}
			};
		});

		mounted_components.set(component, unmount);
		return component;
	}

	/**
	 * References of the components that were mounted or hydrated.
	 * Uses a `WeakMap` to avoid memory leaks.
	 */
	let mounted_components = new WeakMap();

	/**
	 * Unmounts a component that was previously mounted using `mount` or `hydrate`.
	 *
	 * Since 5.13.0, if `options.outro` is `true`, [transitions](https://svelte.dev/docs/svelte/transition) will play before the component is removed from the DOM.
	 *
	 * Returns a `Promise` that resolves after transitions have completed if `options.outro` is true, or immediately otherwise (prior to 5.13.0, returns `void`).
	 *
	 * ```js
	 * import { mount, unmount } from 'svelte';
	 * import App from './App.svelte';
	 *
	 * const app = mount(App, { target: document.body });
	 *
	 * // later...
	 * unmount(app, { outro: true });
	 * ```
	 * @param {Record<string, any>} component
	 * @param {{ outro?: boolean }} [options]
	 * @returns {Promise<void>}
	 */
	function unmount(component, options) {
		const fn = mounted_components.get(component);

		if (fn) {
			mounted_components.delete(component);
			return fn(options);
		}

		return Promise.resolve();
	}

	/** @typedef {{ file: string, line: number, column: number }} Location */


	/**
	 * Sets up a validator that
	 * - traverses the path of a prop to find out if it is allowed to be mutated
	 * - checks that the binding chain is not interrupted
	 * @param {Record<string, any>} props
	 */
	function create_ownership_validator(props) {
		const component = component_context?.function;
		const parent = component_context?.p?.function;

		return {
			/**
			 * @param {string} prop
			 * @param {any[]} path
			 * @param {any} result
			 * @param {number} line
			 * @param {number} column
			 */
			mutation: (prop, path, result, line, column) => {
				const name = path[0];
				if (is_bound_or_unset(props, name) || !parent) {
					return result;
				}

				/** @type {any} */
				let value = props;

				for (let i = 0; i < path.length - 1; i++) {
					value = value[path[i]];
					if (!value?.[STATE_SYMBOL]) {
						return result;
					}
				}

				const location = sanitize_location(`${component[FILENAME]}:${line}:${column}`);

				ownership_invalid_mutation(name, location, prop, parent[FILENAME]);

				return result;
			},
			/**
			 * @param {any} key
			 * @param {any} child_component
			 * @param {() => any} value
			 */
			binding: (key, child_component, value) => {
				if (!is_bound_or_unset(props, key) && parent && value()?.[STATE_SYMBOL]) {
					ownership_invalid_binding(
						component[FILENAME],
						key,
						child_component[FILENAME],
						parent[FILENAME]
					);
				}
			}
		};
	}

	/**
	 * @param {Record<string, any>} props
	 * @param {string} prop_name
	 */
	function is_bound_or_unset(props, prop_name) {
		// Can be the case when someone does `mount(Component, props)` with `let props = $state({...})`
		// or `createClassComponent(Component, props)`
		const is_entry_props = STATE_SYMBOL in props || LEGACY_PROPS in props;
		return (
			!!get_descriptor(props, prop_name)?.set ||
			(is_entry_props && prop_name in props) ||
			!(prop_name in props)
		);
	}

	/** @param {Function & { [FILENAME]: string }} target */
	function check_target(target) {
		if (target) {
			component_api_invalid_new(target[FILENAME] ?? 'a component', target.name);
		}
	}

	function legacy_api() {
		const component = component_context?.function;

		/** @param {string} method */
		function error(method) {
			component_api_changed(method, component[FILENAME]);
		}

		return {
			$destroy: () => error('$destroy()'),
			$on: () => error('$on(...)'),
			$set: () => error('$set(...)')
		};
	}

	/**
	 * @param {Node} anchor
	 * @param {...(()=>any)[]} args
	 */
	function validate_snippet_args(anchor, ...args) {
		if (typeof anchor !== 'object' || !(anchor instanceof Node)) {
			invalid_snippet_arguments();
		}
		for (let arg of args) {
			if (typeof arg !== 'function') {
				invalid_snippet_arguments();
			}
		}
	}

	/** @import { Effect, Source, TemplateNode } from '#client' */

	const PENDING = 0;
	const THEN = 1;
	const CATCH = 2;

	/**
	 * @template V
	 * @param {TemplateNode} node
	 * @param {(() => Promise<V>)} get_input
	 * @param {null | ((anchor: Node) => void)} pending_fn
	 * @param {null | ((anchor: Node, value: Source<V>) => void)} then_fn
	 * @param {null | ((anchor: Node, error: unknown) => void)} catch_fn
	 * @returns {void}
	 */
	function await_block(node, get_input, pending_fn, then_fn, catch_fn) {
		if (hydrating) {
			hydrate_next();
		}

		var anchor = node;
		var active_component_context = component_context;

		/** @type {V | Promise<V> | typeof UNINITIALIZED} */
		var input = UNINITIALIZED;

		/** @type {Effect | null} */
		var pending_effect;

		/** @type {Effect | null} */
		var then_effect;

		/** @type {Effect | null} */
		var catch_effect;

		var input_source = (source )(/** @type {V} */ (undefined));
		var error_source = (source )(undefined);
		var resolved = false;

		/**
		 * @param {PENDING | THEN | CATCH} state
		 * @param {boolean} restore
		 */
		function update(state, restore) {
			resolved = true;

			if (restore) {
				set_active_effect(effect);
				set_active_reaction(effect); // TODO do we need both?
				set_component_context(active_component_context);
			}

			try {
				if (state === PENDING && pending_fn) {
					if (pending_effect) resume_effect(pending_effect);
					else pending_effect = branch(() => pending_fn(anchor));
				}

				if (state === THEN && then_fn) {
					if (then_effect) resume_effect(then_effect);
					else then_effect = branch(() => then_fn(anchor, input_source));
				}

				if (state === CATCH && catch_fn) ;

				if (state !== PENDING && pending_effect) {
					pause_effect(pending_effect, () => (pending_effect = null));
				}

				if (state !== THEN && then_effect) {
					pause_effect(then_effect, () => (then_effect = null));
				}

				if (state !== CATCH && catch_effect) {
					pause_effect(catch_effect, () => (catch_effect = null));
				}
			} finally {
				if (restore) {
					set_component_context(null);
					set_active_reaction(null);
					set_active_effect(null);

					// without this, the DOM does not update until two ticks after the promise
					// resolves, which is unexpected behaviour (and somewhat irksome to test)
					flushSync();
				}
			}
		}

		var effect = block(() => {
			if (input === (input = get_input())) return;

			/** Whether or not there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */
			// @ts-ignore coercing `anchor` to a `Comment` causes TypeScript and Prettier to fight
			let mismatch = hydrating && is_promise(input) === (anchor.data === HYDRATION_START_ELSE);

			if (mismatch) {
				// Hydration mismatch: remove everything inside the anchor and start fresh
				anchor = remove_nodes();

				set_hydrate_node(anchor);
				set_hydrating(false);
				mismatch = true;
			}

			if (is_promise(input)) {
				var promise = input;

				resolved = false;

				promise.then(
					(value) => {
						if (promise !== input) return;
						// we technically could use `set` here since it's on the next microtick
						// but let's use internal_set for consistency and just to be safe
						internal_set(input_source, value);
						update(THEN, true);
					},
					(error) => {
						if (promise !== input) return;
						// we technically could use `set` here since it's on the next microtick
						// but let's use internal_set for consistency and just to be safe
						internal_set(error_source, error);
						update(CATCH, true);
						{
							// Rethrow the error if no catch block exists
							throw error_source.v;
						}
					}
				);

				if (hydrating) {
					if (pending_fn) {
						pending_effect = branch(() => pending_fn(anchor));
					}
				} else {
					// Wait a microtask before checking if we should show the pending state as
					// the promise might have resolved by the next microtask.
					queue_micro_task(() => {
						if (!resolved) update(PENDING, true);
					});
				}
			} else {
				internal_set(input_source, input);
				update(THEN, false);
			}

			if (mismatch) {
				// continue in hydration mode
				set_hydrating(true);
			}

			// Set the input to something else, in order to disable the promise callbacks
			return () => (input = UNINITIALIZED);
		});

		if (hydrating) {
			anchor = hydrate_node;
		}
	}

	/** @import { Effect, TemplateNode } from '#client' */

	/**
	 * @param {TemplateNode} node
	 * @param {(branch: (fn: (anchor: Node, elseif?: [number,number]) => void, flag?: boolean) => void) => void} fn
	 * @param {[number,number]} [elseif]
	 * @returns {void}
	 */
	function if_block(node, fn, [root_index, hydrate_index] = [0, 0]) {
		if (hydrating && root_index === 0) {
			hydrate_next();
		}

		var anchor = node;

		/** @type {Effect | null} */
		var consequent_effect = null;

		/** @type {Effect | null} */
		var alternate_effect = null;

		/** @type {UNINITIALIZED | boolean | null} */
		var condition = UNINITIALIZED;

		var flags = root_index > 0 ? EFFECT_TRANSPARENT : 0;

		var has_branch = false;

		const set_branch = (
			/** @type {(anchor: Node, elseif?: [number,number]) => void} */ fn,
			flag = true
		) => {
			has_branch = true;
			update_branch(flag, fn);
		};

		const update_branch = (
			/** @type {boolean | null} */ new_condition,
			/** @type {null | ((anchor: Node, elseif?: [number,number]) => void)} */ fn
		) => {
			if (condition === (condition = new_condition)) return;

			/** Whether or not there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */
			let mismatch = false;

			if (hydrating && hydrate_index !== -1) {
				if (root_index === 0) {
					const data = /** @type {Comment} */ (anchor).data;
					if (data === HYDRATION_START) {
						hydrate_index = 0;
					} else if (data === HYDRATION_START_ELSE) {
						hydrate_index = Infinity;
					} else {
						hydrate_index = parseInt(data.substring(1));
						if (hydrate_index !== hydrate_index) {
							// if hydrate_index is NaN
							// we set an invalid index to force mismatch
							hydrate_index = condition ? Infinity : -1;
						}
					}
				}
				const is_else = hydrate_index > root_index;

				if (!!condition === is_else) {
					// Hydration mismatch: remove everything inside the anchor and start fresh.
					// This could happen with `{#if browser}...{/if}`, for example
					anchor = remove_nodes();

					set_hydrate_node(anchor);
					set_hydrating(false);
					mismatch = true;
					hydrate_index = -1; // ignore hydration in next else if
				}
			}

			if (condition) {
				if (consequent_effect) {
					resume_effect(consequent_effect);
				} else if (fn) {
					consequent_effect = branch(() => fn(anchor));
				}

				if (alternate_effect) {
					pause_effect(alternate_effect, () => {
						alternate_effect = null;
					});
				}
			} else {
				if (alternate_effect) {
					resume_effect(alternate_effect);
				} else if (fn) {
					alternate_effect = branch(() => fn(anchor, [root_index + 1, hydrate_index]));
				}

				if (consequent_effect) {
					pause_effect(consequent_effect, () => {
						consequent_effect = null;
					});
				}
			}

			if (mismatch) {
				// continue in hydration mode
				set_hydrating(true);
			}
		};

		block(() => {
			has_branch = false;
			fn(set_branch);
			if (!has_branch) {
				update_branch(null, null);
			}
		}, flags);

		if (hydrating) {
			anchor = hydrate_node;
		}
	}

	/** @import { EachItem, EachState, Effect, MaybeSource, Source, TemplateNode, TransitionManager, Value } from '#client' */

	/**
	 * @param {any} _
	 * @param {number} i
	 */
	function index(_, i) {
		return i;
	}

	/**
	 * Pause multiple effects simultaneously, and coordinate their
	 * subsequent destruction. Used in each blocks
	 * @param {EachState} state
	 * @param {EachItem[]} items
	 * @param {null | Node} controlled_anchor
	 * @param {Map<any, EachItem>} items_map
	 */
	function pause_effects(state, items, controlled_anchor, items_map) {
		/** @type {TransitionManager[]} */
		var transitions = [];
		var length = items.length;

		for (var i = 0; i < length; i++) {
			pause_children(items[i].e, transitions, true);
		}

		var is_controlled = length > 0 && transitions.length === 0 && controlled_anchor !== null;
		// If we have a controlled anchor, it means that the each block is inside a single
		// DOM element, so we can apply a fast-path for clearing the contents of the element.
		if (is_controlled) {
			var parent_node = /** @type {Element} */ (
				/** @type {Element} */ (controlled_anchor).parentNode
			);
			clear_text_content(parent_node);
			parent_node.append(/** @type {Element} */ (controlled_anchor));
			items_map.clear();
			link(state, items[0].prev, items[length - 1].next);
		}

		run_out_transitions(transitions, () => {
			for (var i = 0; i < length; i++) {
				var item = items[i];
				if (!is_controlled) {
					items_map.delete(item.k);
					link(state, item.prev, item.next);
				}
				destroy_effect(item.e, !is_controlled);
			}
		});
	}

	/**
	 * @template V
	 * @param {Element | Comment} node The next sibling node, or the parent node if this is a 'controlled' block
	 * @param {number} flags
	 * @param {() => V[]} get_collection
	 * @param {(value: V, index: number) => any} get_key
	 * @param {(anchor: Node, item: MaybeSource<V>, index: MaybeSource<number>) => void} render_fn
	 * @param {null | ((anchor: Node) => void)} fallback_fn
	 * @returns {void}
	 */
	function each(node, flags, get_collection, get_key, render_fn, fallback_fn = null) {
		var anchor = node;

		/** @type {EachState} */
		var state = { flags, items: new Map(), first: null };

		{
			var parent_node = /** @type {Element} */ (node);

			anchor = hydrating
				? set_hydrate_node(/** @type {Comment | Text} */ (get_first_child(parent_node)))
				: parent_node.appendChild(create_text());
		}

		if (hydrating) {
			hydrate_next();
		}

		/** @type {Effect | null} */
		var fallback = null;

		var was_empty = false;

		// TODO: ideally we could use derived for runes mode but because of the ability
		// to use a store which can be mutated, we can't do that here as mutating a store
		// will still result in the collection array being the same from the store
		var each_array = derived_safe_equal(() => {
			var collection = get_collection();

			return is_array(collection) ? collection : collection == null ? [] : array_from(collection);
		});

		block(() => {
			var array = get(each_array);
			var length = array.length;

			if (was_empty && length === 0) {
				// ignore updates if the array is empty,
				// and it already was empty on previous run
				return;
			}
			was_empty = length === 0;

			/** `true` if there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */
			let mismatch = false;

			if (hydrating) {
				var is_else = /** @type {Comment} */ (anchor).data === HYDRATION_START_ELSE;

				if (is_else !== (length === 0)) {
					// hydration mismatch — remove the server-rendered DOM and start over
					anchor = remove_nodes();

					set_hydrate_node(anchor);
					set_hydrating(false);
					mismatch = true;
				}
			}

			// this is separate to the previous block because `hydrating` might change
			if (hydrating) {
				/** @type {EachItem | null} */
				var prev = null;

				/** @type {EachItem} */
				var item;

				for (var i = 0; i < length; i++) {
					if (
						hydrate_node.nodeType === 8 &&
						/** @type {Comment} */ (hydrate_node).data === HYDRATION_END
					) {
						// The server rendered fewer items than expected,
						// so break out and continue appending non-hydrated items
						anchor = /** @type {Comment} */ (hydrate_node);
						mismatch = true;
						set_hydrating(false);
						break;
					}

					var value = array[i];
					var key = get_key(value, i);
					item = create_item(
						hydrate_node,
						state,
						prev,
						null,
						value,
						key,
						i,
						render_fn,
						flags,
						get_collection
					);
					state.items.set(key, item);

					prev = item;
				}

				// remove excess nodes
				if (length > 0) {
					set_hydrate_node(remove_nodes());
				}
			}

			if (!hydrating) {
				reconcile(array, state, anchor, render_fn, flags, get_key, get_collection);
			}

			if (fallback_fn !== null) {
				if (length === 0) {
					if (fallback) {
						resume_effect(fallback);
					} else {
						fallback = branch(() => fallback_fn(anchor));
					}
				} else if (fallback !== null) {
					pause_effect(fallback, () => {
						fallback = null;
					});
				}
			}

			if (mismatch) {
				// continue in hydration mode
				set_hydrating(true);
			}

			// When we mount the each block for the first time, the collection won't be
			// connected to this effect as the effect hasn't finished running yet and its deps
			// won't be assigned. However, it's possible that when reconciling the each block
			// that a mutation occurred and it's made the collection MAYBE_DIRTY, so reading the
			// collection again can provide consistency to the reactive graph again as the deriveds
			// will now be `CLEAN`.
			get(each_array);
		});

		if (hydrating) {
			anchor = hydrate_node;
		}
	}

	/**
	 * Add, remove, or reorder items output by an each block as its input changes
	 * @template V
	 * @param {Array<V>} array
	 * @param {EachState} state
	 * @param {Element | Comment | Text} anchor
	 * @param {(anchor: Node, item: MaybeSource<V>, index: number | Source<number>, collection: () => V[]) => void} render_fn
	 * @param {number} flags
	 * @param {(value: V, index: number) => any} get_key
	 * @param {() => V[]} get_collection
	 * @returns {void}
	 */
	function reconcile(array, state, anchor, render_fn, flags, get_key, get_collection) {

		var length = array.length;
		var items = state.items;
		var first = state.first;
		var current = first;

		/** @type {undefined | Set<EachItem>} */
		var seen;

		/** @type {EachItem | null} */
		var prev = null;

		/** @type {EachItem[]} */
		var matched = [];

		/** @type {EachItem[]} */
		var stashed = [];

		/** @type {V} */
		var value;

		/** @type {any} */
		var key;

		/** @type {EachItem | undefined} */
		var item;

		/** @type {number} */
		var i;

		for (i = 0; i < length; i += 1) {
			value = array[i];
			key = get_key(value, i);
			item = items.get(key);

			if (item === undefined) {
				var child_anchor = current ? /** @type {TemplateNode} */ (current.e.nodes_start) : anchor;

				prev = create_item(
					child_anchor,
					state,
					prev,
					prev === null ? state.first : prev.next,
					value,
					key,
					i,
					render_fn,
					flags,
					get_collection
				);

				items.set(key, prev);

				matched = [];
				stashed = [];

				current = prev.next;
				continue;
			}

			{
				update_item(item, value, i);
			}

			if ((item.e.f & INERT) !== 0) {
				resume_effect(item.e);
			}

			if (item !== current) {
				if (seen !== undefined && seen.has(item)) {
					if (matched.length < stashed.length) {
						// more efficient to move later items to the front
						var start = stashed[0];
						var j;

						prev = start.prev;

						var a = matched[0];
						var b = matched[matched.length - 1];

						for (j = 0; j < matched.length; j += 1) {
							move(matched[j], start, anchor);
						}

						for (j = 0; j < stashed.length; j += 1) {
							seen.delete(stashed[j]);
						}

						link(state, a.prev, b.next);
						link(state, prev, a);
						link(state, b, start);

						current = start;
						prev = b;
						i -= 1;

						matched = [];
						stashed = [];
					} else {
						// more efficient to move earlier items to the back
						seen.delete(item);
						move(item, current, anchor);

						link(state, item.prev, item.next);
						link(state, item, prev === null ? state.first : prev.next);
						link(state, prev, item);

						prev = item;
					}

					continue;
				}

				matched = [];
				stashed = [];

				while (current !== null && current.k !== key) {
					// If the each block isn't inert and an item has an effect that is already inert,
					// skip over adding it to our seen Set as the item is already being handled
					if ((current.e.f & INERT) === 0) {
						(seen ??= new Set()).add(current);
					}
					stashed.push(current);
					current = current.next;
				}

				if (current === null) {
					continue;
				}

				item = current;
			}

			matched.push(item);
			prev = item;
			current = item.next;
		}

		if (current !== null || seen !== undefined) {
			var to_destroy = seen === undefined ? [] : array_from(seen);

			while (current !== null) {
				// If the each block isn't inert, then inert effects are currently outroing and will be removed once the transition is finished
				if ((current.e.f & INERT) === 0) {
					to_destroy.push(current);
				}
				current = current.next;
			}

			var destroy_length = to_destroy.length;

			if (destroy_length > 0) {
				var controlled_anchor = length === 0 ? anchor : null;

				pause_effects(state, to_destroy, controlled_anchor, items);
			}
		}

		/** @type {Effect} */ (active_effect).first = state.first && state.first.e;
		/** @type {Effect} */ (active_effect).last = prev && prev.e;
	}

	/**
	 * @param {EachItem} item
	 * @param {any} value
	 * @param {number} index
	 * @param {number} type
	 * @returns {void}
	 */
	function update_item(item, value, index, type) {
		{
			internal_set(item.v, value);
		}

		{
			item.i = index;
		}
	}

	/**
	 * @template V
	 * @param {Node} anchor
	 * @param {EachState} state
	 * @param {EachItem | null} prev
	 * @param {EachItem | null} next
	 * @param {V} value
	 * @param {unknown} key
	 * @param {number} index
	 * @param {(anchor: Node, item: V | Source<V>, index: number | Value<number>, collection: () => V[]) => void} render_fn
	 * @param {number} flags
	 * @param {() => V[]} get_collection
	 * @returns {EachItem}
	 */
	function create_item(
		anchor,
		state,
		prev,
		next,
		value,
		key,
		index,
		render_fn,
		flags,
		get_collection
	) {
		var reactive = (flags & EACH_ITEM_REACTIVE) !== 0;
		var mutable = (flags & EACH_ITEM_IMMUTABLE) === 0;

		var v = reactive ? (mutable ? mutable_source(value) : source(value)) : value;
		var i = (flags & EACH_INDEX_REACTIVE) === 0 ? index : source(index);

		/** @type {EachItem} */
		var item = {
			i,
			v,
			k: key,
			a: null,
			// @ts-expect-error
			e: null,
			prev,
			next
		};

		try {
			item.e = branch(() => render_fn(anchor, v, i, get_collection), hydrating);

			item.e.prev = prev && prev.e;
			item.e.next = next && next.e;

			if (prev === null) {
				state.first = item;
			} else {
				prev.next = item;
				prev.e.next = item.e;
			}

			if (next !== null) {
				next.prev = item;
				next.e.prev = item.e;
			}

			return item;
		} finally {
		}
	}

	/**
	 * @param {EachItem} item
	 * @param {EachItem | null} next
	 * @param {Text | Element | Comment} anchor
	 */
	function move(item, next, anchor) {
		var end = item.next ? /** @type {TemplateNode} */ (item.next.e.nodes_start) : anchor;

		var dest = next ? /** @type {TemplateNode} */ (next.e.nodes_start) : anchor;
		var node = /** @type {TemplateNode} */ (item.e.nodes_start);

		while (node !== end) {
			var next_node = /** @type {TemplateNode} */ (get_next_sibling(node));
			dest.before(node);
			node = next_node;
		}
	}

	/**
	 * @param {EachState} state
	 * @param {EachItem | null} prev
	 * @param {EachItem | null} next
	 */
	function link(state, prev, next) {
		if (prev === null) {
			state.first = next;
		} else {
			prev.next = next;
			prev.e.next = next && next.e;
		}

		if (next !== null) {
			next.prev = prev;
			next.e.prev = prev && prev.e;
		}
	}

	/** @import { Effect, TemplateNode } from '#client' */

	/**
	 * @param {Element | Text | Comment} node
	 * @param {() => string} get_value
	 * @param {boolean} [svg]
	 * @param {boolean} [mathml]
	 * @param {boolean} [skip_warning]
	 * @returns {void}
	 */
	function html(node, get_value, svg = false, mathml = false, skip_warning = false) {
		var anchor = node;

		var value = '';

		template_effect(() => {
			var effect = /** @type {Effect} */ (active_effect);

			if (value === (value = get_value() ?? '')) {
				if (hydrating) hydrate_next();
				return;
			}

			if (effect.nodes_start !== null) {
				remove_effect_dom(effect.nodes_start, /** @type {TemplateNode} */ (effect.nodes_end));
				effect.nodes_start = effect.nodes_end = null;
			}

			if (value === '') return;

			if (hydrating) {
				// We're deliberately not trying to repair mismatches between server and client,
				// as it's costly and error-prone (and it's an edge case to have a mismatch anyway)
				/** @type {Comment} */ (hydrate_node).data;
				var next = hydrate_next();
				var last = next;

				while (next !== null && (next.nodeType !== 8 || /** @type {Comment} */ (next).data !== '')) {
					last = next;
					next = /** @type {TemplateNode} */ (get_next_sibling(next));
				}

				if (next === null) {
					hydration_mismatch();
					throw HYDRATION_ERROR;
				}

				assign_nodes(hydrate_node, last);
				anchor = set_hydrate_node(next);
				return;
			}

			var html = value + '';
			if (svg) html = `<svg>${html}</svg>`;
			else if (mathml) html = `<math>${html}</math>`;

			// Don't use create_fragment_with_script_from_html here because that would mean script tags are executed.
			// @html is basically `.innerHTML = ...` and that doesn't execute scripts either due to security reasons.
			/** @type {DocumentFragment | Element} */
			var node = create_fragment_from_html(html);

			if (svg || mathml) {
				node = /** @type {Element} */ (get_first_child(node));
			}

			assign_nodes(
				/** @type {TemplateNode} */ (get_first_child(node)),
				/** @type {TemplateNode} */ (node.lastChild)
			);

			if (svg || mathml) {
				while (get_first_child(node)) {
					anchor.before(/** @type {Node} */ (get_first_child(node)));
				}
			} else {
				anchor.before(node);
			}
		});
	}

	/**
	 * @param {Comment} anchor
	 * @param {Record<string, any>} $$props
	 * @param {string} name
	 * @param {Record<string, unknown>} slot_props
	 * @param {null | ((anchor: Comment) => void)} fallback_fn
	 */
	function slot(anchor, $$props, name, slot_props, fallback_fn) {
		if (hydrating) {
			hydrate_next();
		}

		var slot_fn = $$props.$$slots?.[name];
		// Interop: Can use snippets to fill slots
		var is_interop = false;
		if (slot_fn === true) {
			slot_fn = $$props[name === 'default' ? 'children' : name];
			is_interop = true;
		}

		if (slot_fn === undefined) ; else {
			slot_fn(anchor, is_interop ? () => slot_props : slot_props);
		}
	}

	/**
	 * @param {Record<string, any>} props
	 * @returns {Record<string, boolean>}
	 */
	function sanitize_slots(props) {
		/** @type {Record<string, boolean>} */
		const sanitized = {};
		if (props.children) sanitized.default = true;
		for (const key in props.$$slots) {
			sanitized[key] = true;
		}
		return sanitized;
	}

	/** @import { TemplateNode } from '#client' */
	/** @import { Getters } from '#shared' */

	/**
	 * @param {() => string} tag_fn
	 * @returns {void}
	 */
	function validate_void_dynamic_element(tag_fn) {
		const tag = tag_fn();
		if (tag && is_void(tag)) {
			dynamic_void_element_content();
		}
	}

	/** @param {() => unknown} tag_fn */
	function validate_dynamic_element_tag(tag_fn) {
		const tag = tag_fn();
		const is_string = typeof tag === 'string';
		if (tag && !is_string) {
			svelte_element_invalid_this_value();
		}
	}

	/**
	 * @template {() => unknown} T
	 * @param {T} fn
	 */
	function prevent_snippet_stringification(fn) {
		fn.toString = () => {
			snippet_without_render_tag();
			return '';
		};
		return fn;
	}

	/** @import { Snippet } from 'svelte' */
	/** @import { Effect, TemplateNode } from '#client' */
	/** @import { Getters } from '#shared' */

	/**
	 * @template {(node: TemplateNode, ...args: any[]) => void} SnippetFn
	 * @param {TemplateNode} node
	 * @param {() => SnippetFn | null | undefined} get_snippet
	 * @param {(() => any)[]} args
	 * @returns {void}
	 */
	function snippet(node, get_snippet, ...args) {
		var anchor = node;

		/** @type {SnippetFn | null | undefined} */
		// @ts-ignore
		var snippet = noop;

		/** @type {Effect | null} */
		var snippet_effect;

		block(() => {
			if (snippet === (snippet = get_snippet())) return;

			if (snippet_effect) {
				destroy_effect(snippet_effect);
				snippet_effect = null;
			}

			snippet_effect = branch(() => /** @type {SnippetFn} */ (snippet)(anchor, ...args));
		}, EFFECT_TRANSPARENT);

		if (hydrating) {
			anchor = hydrate_node;
		}
	}

	/**
	 * In development, wrap the snippet function so that it passes validation, and so that the
	 * correct component context is set for ownership checks
	 * @param {any} component
	 * @param {(node: TemplateNode, ...args: any[]) => void} fn
	 */
	function wrap_snippet(component, fn) {
		const snippet = (/** @type {TemplateNode} */ node, /** @type {any[]} */ ...args) => {
			var previous_component_function = dev_current_component_function;
			set_dev_current_component_function(component);

			try {
				return fn(node, ...args);
			} finally {
				set_dev_current_component_function(previous_component_function);
			}
		};

		prevent_snippet_stringification(snippet);

		return snippet;
	}

	/** @import { Effect, TemplateNode } from '#client' */

	/**
	 * @param {Comment | Element} node
	 * @param {() => string} get_tag
	 * @param {boolean} is_svg
	 * @param {undefined | ((element: Element, anchor: Node | null) => void)} render_fn,
	 * @param {undefined | (() => string)} get_namespace
	 * @param {undefined | [number, number]} location
	 * @returns {void}
	 */
	function element(node, get_tag, is_svg, render_fn, get_namespace, location) {
		let was_hydrating = hydrating;

		if (hydrating) {
			hydrate_next();
		}

		/** @type {string | null} */
		var tag;

		/** @type {string | null} */
		var current_tag;

		/** @type {null | Element} */
		var element = null;

		if (hydrating && hydrate_node.nodeType === 1) {
			element = /** @type {Element} */ (hydrate_node);
			hydrate_next();
		}

		var anchor = /** @type {TemplateNode} */ (hydrating ? hydrate_node : node);

		/** @type {Effect | null} */
		var effect;

		block(() => {
			const next_tag = get_tag() || null;
			var ns = next_tag === 'svg' ? NAMESPACE_SVG : null;

			// Assumption: Noone changes the namespace but not the tag (what would that even mean?)
			if (next_tag === tag) return;

			if (effect) {
				if (next_tag === null) {
					// start outro
					pause_effect(effect, () => {
						effect = null;
						current_tag = null;
					});
				} else if (next_tag === current_tag) {
					// same tag as is currently rendered — abort outro
					resume_effect(effect);
				} else {
					// tag is changing — destroy immediately, render contents without intro transitions
					destroy_effect(effect);
				}
			}

			if (next_tag && next_tag !== current_tag) {
				effect = branch(() => {
					element = hydrating
						? /** @type {Element} */ (element)
						: ns
							? document.createElementNS(ns, next_tag)
							: document.createElement(next_tag);

					assign_nodes(element, element);

					if (render_fn) {
						if (hydrating && is_raw_text_element(next_tag)) {
							// prevent hydration glitches
							element.append(document.createComment(''));
						}

						// If hydrating, use the existing ssr comment as the anchor so that the
						// inner open and close methods can pick up the existing nodes correctly
						var child_anchor = /** @type {TemplateNode} */ (
							hydrating ? get_first_child(element) : element.appendChild(create_text())
						);

						if (hydrating) {
							if (child_anchor === null) {
								set_hydrating(false);
							} else {
								set_hydrate_node(child_anchor);
							}
						}

						// `child_anchor` is undefined if this is a void element, but we still
						// need to call `render_fn` in order to run actions etc. If the element
						// contains children, it's a user error (which is warned on elsewhere)
						// and the DOM will be silently discarded
						render_fn(element, child_anchor);
					}

					// we do this after calling `render_fn` so that child effects don't override `nodes.end`
					/** @type {Effect} */ (active_effect).nodes_end = element;

					anchor.before(element);
				});
			}

			tag = next_tag;
			if (tag) current_tag = tag;
		}, EFFECT_TRANSPARENT);

		if (was_hydrating) {
			set_hydrating(true);
			set_hydrate_node(anchor);
		}
	}

	function r(e){var t,f,n="";if("string"==typeof e||"number"==typeof e)n+=e;else if("object"==typeof e)if(Array.isArray(e)){var o=e.length;for(t=0;t<o;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=" "),n+=f);}else for(f in e)e[f]&&(n&&(n+=" "),n+=f);return n}function clsx$1(){for(var e,t,f=0,n="",o=arguments.length;f<o;f++)(e=arguments[f])&&(t=r(e))&&(n&&(n+=" "),n+=t);return n}

	/**
	 * Small wrapper around clsx to preserve Svelte's (weird) handling of falsy values.
	 * TODO Svelte 6 revisit this, and likely turn all falsy values into the empty string (what clsx also does)
	 * @param  {any} value
	 */
	function clsx(value) {
		if (typeof value === 'object') {
			return clsx$1(value);
		} else {
			return value ?? '';
		}
	}

	const whitespace = [...' \t\n\r\f\u00a0\u000b\ufeff'];

	/**
	 * @param {any} value
	 * @param {string | null} [hash]
	 * @param {Record<string, boolean>} [directives]
	 * @returns {string | null}
	 */
	function to_class(value, hash, directives) {
		var classname = value == null ? '' : '' + value;

		if (hash) {
			classname = classname ? classname + ' ' + hash : hash;
		}

		if (directives) {
			for (var key in directives) {
				if (directives[key]) {
					classname = classname ? classname + ' ' + key : key;
				} else if (classname.length) {
					var len = key.length;
					var a = 0;

					while ((a = classname.indexOf(key, a)) >= 0) {
						var b = a + len;

						if (
							(a === 0 || whitespace.includes(classname[a - 1])) &&
							(b === classname.length || whitespace.includes(classname[b]))
						) {
							classname = (a === 0 ? '' : classname.substring(0, a)) + classname.substring(b + 1);
						} else {
							a = b;
						}
					}
				}
			}
		}

		return classname === '' ? null : classname;
	}

	/**
	 *
	 * @param {Record<string,any>} styles
	 * @param {boolean} important
	 */
	function append_styles(styles, important = false) {
		var separator = important ? ' !important;' : ';';
		var css = '';

		for (var key in styles) {
			var value = styles[key];
			if (value != null && value !== '') {
				css += ' ' + key + ': ' + value + separator;
			}
		}

		return css;
	}

	/**
	 * @param {string} name
	 * @returns {string}
	 */
	function to_css_name(name) {
		if (name[0] !== '-' || name[1] !== '-') {
			return name.toLowerCase();
		}
		return name;
	}

	/**
	 * @param {any} value
	 * @param {Record<string, any> | [Record<string, any>, Record<string, any>]} [styles]
	 * @returns {string | null}
	 */
	function to_style(value, styles) {
		if (styles) {
			var new_style = '';

			/** @type {Record<string,any> | undefined} */
			var normal_styles;

			/** @type {Record<string,any> | undefined} */
			var important_styles;

			if (Array.isArray(styles)) {
				normal_styles = styles[0];
				important_styles = styles[1];
			} else {
				normal_styles = styles;
			}

			if (value) {
				value = String(value)
					.replaceAll(/\s*\/\*.*?\*\/\s*/g, '')
					.trim();

				/** @type {boolean | '"' | "'"} */
				var in_str = false;
				var in_apo = 0;
				var in_comment = false;

				var reserved_names = [];

				if (normal_styles) {
					reserved_names.push(...Object.keys(normal_styles).map(to_css_name));
				}
				if (important_styles) {
					reserved_names.push(...Object.keys(important_styles).map(to_css_name));
				}

				var start_index = 0;
				var name_index = -1;

				const len = value.length;
				for (var i = 0; i < len; i++) {
					var c = value[i];

					if (in_comment) {
						if (c === '/' && value[i - 1] === '*') {
							in_comment = false;
						}
					} else if (in_str) {
						if (in_str === c) {
							in_str = false;
						}
					} else if (c === '/' && value[i + 1] === '*') {
						in_comment = true;
					} else if (c === '"' || c === "'") {
						in_str = c;
					} else if (c === '(') {
						in_apo++;
					} else if (c === ')') {
						in_apo--;
					}

					if (!in_comment && in_str === false && in_apo === 0) {
						if (c === ':' && name_index === -1) {
							name_index = i;
						} else if (c === ';' || i === len - 1) {
							if (name_index !== -1) {
								var name = to_css_name(value.substring(start_index, name_index).trim());

								if (!reserved_names.includes(name)) {
									if (c !== ';') {
										i++;
									}

									var property = value.substring(start_index, i).trim();
									new_style += ' ' + property + ';';
								}
							}

							start_index = i + 1;
							name_index = -1;
						}
					}
				}
			}

			if (normal_styles) {
				new_style += append_styles(normal_styles);
			}

			if (important_styles) {
				new_style += append_styles(important_styles, true);
			}

			new_style = new_style.trim();
			return new_style === '' ? null : new_style;
		}

		return value == null ? null : String(value);
	}

	/**
	 * @param {Element} dom
	 * @param {boolean | number} is_html
	 * @param {string | null} value
	 * @param {string} [hash]
	 * @param {Record<string, any>} [prev_classes]
	 * @param {Record<string, any>} [next_classes]
	 * @returns {Record<string, boolean> | undefined}
	 */
	function set_class(dom, is_html, value, hash, prev_classes, next_classes) {
		// @ts-expect-error need to add __className to patched prototype
		var prev = dom.__className;

		if (
			hydrating ||
			prev !== value ||
			prev === undefined // for edge case of `class={undefined}`
		) {
			var next_class_name = to_class(value, hash, next_classes);

			if (!hydrating || next_class_name !== dom.getAttribute('class')) {
				// Removing the attribute when the value is only an empty string causes
				// performance issues vs simply making the className an empty string. So
				// we should only remove the class if the the value is nullish
				// and there no hash/directives :
				if (next_class_name == null) {
					dom.removeAttribute('class');
				} else if (is_html) {
					dom.className = next_class_name;
				} else {
					dom.setAttribute('class', next_class_name);
				}
			}

			// @ts-expect-error need to add __className to patched prototype
			dom.__className = value;
		} else if (next_classes && prev_classes !== next_classes) {
			for (var key in next_classes) {
				var is_present = !!next_classes[key];

				if (prev_classes == null || is_present !== !!prev_classes[key]) {
					dom.classList.toggle(key, is_present);
				}
			}
		}

		return next_classes;
	}

	/**
	 * @param {Element & ElementCSSInlineStyle} dom
	 * @param {Record<string, any>} prev
	 * @param {Record<string, any>} next
	 * @param {string} [priority]
	 */
	function update_styles(dom, prev = {}, next, priority) {
		for (var key in next) {
			var value = next[key];

			if (prev[key] !== value) {
				if (next[key] == null) {
					dom.style.removeProperty(key);
				} else {
					dom.style.setProperty(key, value, priority);
				}
			}
		}
	}

	/**
	 * @param {Element & ElementCSSInlineStyle} dom
	 * @param {string | null} value
	 * @param {Record<string, any> | [Record<string, any>, Record<string, any>]} [prev_styles]
	 * @param {Record<string, any> | [Record<string, any>, Record<string, any>]} [next_styles]
	 */
	function set_style(dom, value, prev_styles, next_styles) {
		// @ts-expect-error
		var prev = dom.__style;

		if (hydrating || prev !== value) {
			var next_style_attr = to_style(value, next_styles);

			if (!hydrating || next_style_attr !== dom.getAttribute('style')) {
				if (next_style_attr == null) {
					dom.removeAttribute('style');
				} else {
					dom.style.cssText = next_style_attr;
				}
			}

			// @ts-expect-error
			dom.__style = value;
		} else if (next_styles) {
			if (Array.isArray(next_styles)) {
				update_styles(dom, prev_styles?.[0], next_styles[0]);
				update_styles(dom, prev_styles?.[1], next_styles[1], 'important');
			} else {
				update_styles(dom, prev_styles, next_styles);
			}
		}

		return next_styles;
	}

	const CLASS = Symbol('class');
	const STYLE = Symbol('style');

	const IS_CUSTOM_ELEMENT = Symbol('is custom element');
	const IS_HTML = Symbol('is html');

	/**
	 * The value/checked attribute in the template actually corresponds to the defaultValue property, so we need
	 * to remove it upon hydration to avoid a bug when someone resets the form value.
	 * @param {HTMLInputElement} input
	 * @returns {void}
	 */
	function remove_input_defaults(input) {
		if (!hydrating) return;

		var already_removed = false;

		// We try and remove the default attributes later, rather than sync during hydration.
		// Doing it sync during hydration has a negative impact on performance, but deferring the
		// work in an idle task alleviates this greatly. If a form reset event comes in before
		// the idle callback, then we ensure the input defaults are cleared just before.
		var remove_defaults = () => {
			if (already_removed) return;
			already_removed = true;

			// Remove the attributes but preserve the values
			if (input.hasAttribute('value')) {
				var value = input.value;
				set_attribute(input, 'value', null);
				input.value = value;
			}

			if (input.hasAttribute('checked')) {
				var checked = input.checked;
				set_attribute(input, 'checked', null);
				input.checked = checked;
			}
		};

		// @ts-expect-error
		input.__on_r = remove_defaults;
		queue_idle_task(remove_defaults);
		add_form_reset_listener();
	}

	/**
	 * Sets the `selected` attribute on an `option` element.
	 * Not set through the property because that doesn't reflect to the DOM,
	 * which means it wouldn't be taken into account when a form is reset.
	 * @param {HTMLOptionElement} element
	 * @param {boolean} selected
	 */
	function set_selected(element, selected) {
		if (selected) {
			// The selected option could've changed via user selection, and
			// setting the value without this check would set it back.
			if (!element.hasAttribute('selected')) {
				element.setAttribute('selected', '');
			}
		} else {
			element.removeAttribute('selected');
		}
	}

	/**
	 * @param {Element} element
	 * @param {string} attribute
	 * @param {string | null} value
	 * @param {boolean} [skip_warning]
	 */
	function set_attribute(element, attribute, value, skip_warning) {
		var attributes = get_attributes(element);

		if (hydrating) {
			attributes[attribute] = element.getAttribute(attribute);

			if (
				attribute === 'src' ||
				attribute === 'srcset' ||
				(attribute === 'href' && element.nodeName === 'LINK')
			) {

				// If we reset these attributes, they would result in another network request, which we want to avoid.
				// We assume they are the same between client and server as checking if they are equal is expensive
				// (we can't just compare the strings as they can be different between client and server but result in the
				// same url, so we would need to create hidden anchor elements to compare them)
				return;
			}
		}

		if (attributes[attribute] === (attributes[attribute] = value)) return;

		if (attribute === 'loading') {
			// @ts-expect-error
			element[LOADING_ATTR_SYMBOL] = value;
		}

		if (value == null) {
			element.removeAttribute(attribute);
		} else if (typeof value !== 'string' && get_setters(element).includes(attribute)) {
			// @ts-ignore
			element[attribute] = value;
		} else {
			element.setAttribute(attribute, value);
		}
	}

	/**
	 * Spreads attributes onto a DOM element, taking into account the currently set attributes
	 * @param {Element & ElementCSSInlineStyle} element
	 * @param {Record<string | symbol, any> | undefined} prev
	 * @param {Record<string | symbol, any>} next New attributes - this function mutates this object
	 * @param {string} [css_hash]
	 * @param {boolean} [skip_warning]
	 * @returns {Record<string, any>}
	 */
	function set_attributes(element, prev, next, css_hash, skip_warning = false) {
		var attributes = get_attributes(element);

		var is_custom_element = attributes[IS_CUSTOM_ELEMENT];
		var preserve_attribute_case = !attributes[IS_HTML];

		// If we're hydrating but the custom element is from Svelte, and it already scaffolded,
		// then it might run block logic in hydration mode, which we have to prevent.
		let is_hydrating_custom_element = hydrating && is_custom_element;
		if (is_hydrating_custom_element) {
			set_hydrating(false);
		}

		var current = prev || {};
		var is_option_element = element.tagName === 'OPTION';

		for (var key in prev) {
			if (!(key in next)) {
				next[key] = null;
			}
		}

		if (next.class) {
			next.class = clsx(next.class);
		} else if (next[CLASS]) {
			next.class = null; /* force call to set_class() */
		}

		if (next[STYLE]) {
			next.style ??= null; /* force call to set_style() */
		}

		var setters = get_setters(element);

		// since key is captured we use const
		for (const key in next) {
			// let instead of var because referenced in a closure
			let value = next[key];

			// Up here because we want to do this for the initial value, too, even if it's undefined,
			// and this wouldn't be reached in case of undefined because of the equality check below
			if (is_option_element && key === 'value' && value == null) {
				// The <option> element is a special case because removing the value attribute means
				// the value is set to the text content of the option element, and setting the value
				// to null or undefined means the value is set to the string "null" or "undefined".
				// To align with how we handle this case in non-spread-scenarios, this logic is needed.
				// There's a super-edge-case bug here that is left in in favor of smaller code size:
				// Because of the "set missing props to null" logic above, we can't differentiate
				// between a missing value and an explicitly set value of null or undefined. That means
				// that once set, the value attribute of an <option> element can't be removed. This is
				// a very rare edge case, and removing the attribute altogether isn't possible either
				// for the <option value={undefined}> case, so we're not losing any functionality here.
				// @ts-ignore
				element.value = element.__value = '';
				current[key] = value;
				continue;
			}

			if (key === 'class') {
				var is_html = element.namespaceURI === 'http://www.w3.org/1999/xhtml';
				set_class(element, is_html, value, css_hash, prev?.[CLASS], next[CLASS]);
				current[key] = value;
				current[CLASS] = next[CLASS];
				continue;
			}

			if (key === 'style') {
				set_style(element, value, prev?.[STYLE], next[STYLE]);
				current[key] = value;
				current[STYLE] = next[STYLE];
				continue;
			}

			var prev_value = current[key];
			if (value === prev_value) continue;

			current[key] = value;

			var prefix = key[0] + key[1]; // this is faster than key.slice(0, 2)
			if (prefix === '$$') continue;

			if (prefix === 'on') {
				/** @type {{ capture?: true }} */
				const opts = {};
				const event_handle_key = '$$' + key;
				let event_name = key.slice(2);
				var delegated = is_delegated(event_name);

				if (is_capture_event(event_name)) {
					event_name = event_name.slice(0, -7);
					opts.capture = true;
				}

				if (!delegated && prev_value) {
					// Listening to same event but different handler -> our handle function below takes care of this
					// If we were to remove and add listeners in this case, it could happen that the event is "swallowed"
					// (the browser seems to not know yet that a new one exists now) and doesn't reach the handler
					// https://github.com/sveltejs/svelte/issues/11903
					if (value != null) continue;

					element.removeEventListener(event_name, current[event_handle_key], opts);
					current[event_handle_key] = null;
				}

				if (value != null) {
					if (!delegated) {
						/**
						 * @this {any}
						 * @param {Event} evt
						 */
						function handle(evt) {
							current[key].call(this, evt);
						}

						current[event_handle_key] = create_event(event_name, element, handle, opts);
					} else {
						// @ts-ignore
						element[`__${event_name}`] = value;
						delegate([event_name]);
					}
				} else if (delegated) {
					// @ts-ignore
					element[`__${event_name}`] = undefined;
				}
			} else if (key === 'style') {
				// avoid using the setter
				set_attribute(element, key, value);
			} else if (key === 'autofocus') {
				autofocus(/** @type {HTMLElement} */ (element), Boolean(value));
			} else if (!is_custom_element && (key === '__value' || (key === 'value' && value != null))) {
				// @ts-ignore We're not running this for custom elements because __value is actually
				// how Lit stores the current value on the element, and messing with that would break things.
				element.value = element.__value = value;
			} else if (key === 'selected' && is_option_element) {
				set_selected(/** @type {HTMLOptionElement} */ (element), value);
			} else {
				var name = key;
				if (!preserve_attribute_case) {
					name = normalize_attribute(name);
				}

				var is_default = name === 'defaultValue' || name === 'defaultChecked';

				if (value == null && !is_custom_element && !is_default) {
					attributes[key] = null;

					if (name === 'value' || name === 'checked') {
						// removing value/checked also removes defaultValue/defaultChecked — preserve
						let input = /** @type {HTMLInputElement} */ (element);
						const use_default = prev === undefined;
						if (name === 'value') {
							let previous = input.defaultValue;
							input.removeAttribute(name);
							input.defaultValue = previous;
							// @ts-ignore
							input.value = input.__value = use_default ? previous : null;
						} else {
							let previous = input.defaultChecked;
							input.removeAttribute(name);
							input.defaultChecked = previous;
							input.checked = use_default ? previous : false;
						}
					} else {
						element.removeAttribute(key);
					}
				} else if (
					is_default ||
					(setters.includes(name) && (is_custom_element || typeof value !== 'string'))
				) {
					// @ts-ignore
					element[name] = value;
				} else if (typeof value !== 'function') {
					set_attribute(element, name, value);
				}
			}
		}

		if (is_hydrating_custom_element) {
			set_hydrating(true);
		}

		return current;
	}

	/**
	 *
	 * @param {Element} element
	 */
	function get_attributes(element) {
		return /** @type {Record<string | symbol, unknown>} **/ (
			// @ts-expect-error
			element.__attributes ??= {
				[IS_CUSTOM_ELEMENT]: element.nodeName.includes('-'),
				[IS_HTML]: element.namespaceURI === NAMESPACE_HTML
			}
		);
	}

	/** @type {Map<string, string[]>} */
	var setters_cache = new Map();

	/** @param {Element} element */
	function get_setters(element) {
		var setters = setters_cache.get(element.nodeName);
		if (setters) return setters;
		setters_cache.set(element.nodeName, (setters = []));

		var descriptors;
		var proto = element; // In the case of custom elements there might be setters on the instance
		var element_proto = Element.prototype;

		// Stop at Element, from there on there's only unnecessary setters we're not interested in
		// Do not use contructor.name here as that's unreliable in some browser environments
		while (element_proto !== proto) {
			descriptors = get_descriptors(proto);

			for (var key in descriptors) {
				if (descriptors[key].set) {
					setters.push(key);
				}
			}

			proto = get_prototype_of(proto);
		}

		return setters;
	}

	/**
	 * @param {HTMLInputElement} input
	 * @param {() => unknown} get
	 * @param {(value: unknown) => void} set
	 * @returns {void}
	 */
	function bind_value(input, get, set = get) {

		listen_to_event_and_reset_event(input, 'input', (is_reset) => {

			/** @type {any} */
			var value = is_reset ? input.defaultValue : input.value;
			value = is_numberlike_input(input) ? to_number(value) : value;
			set(value);

			// In runes mode, respect any validation in accessors (doesn't apply in legacy mode,
			// because we use mutable state which ensures the render effect always runs)
			if (value !== (value = get())) {
				var start = input.selectionStart;
				var end = input.selectionEnd;

				// the value is coerced on assignment
				input.value = value ?? '';

				// Restore selection
				if (end !== null) {
					input.selectionStart = start;
					input.selectionEnd = Math.min(end, input.value.length);
				}
			}
		});

		if (
			// If we are hydrating and the value has since changed,
			// then use the updated value from the input instead.
			(hydrating && input.defaultValue !== input.value) ||
			// If defaultValue is set, then value == defaultValue
			// TODO Svelte 6: remove input.value check and set to empty string?
			(untrack(get) == null && input.value)
		) {
			set(is_numberlike_input(input) ? to_number(input.value) : input.value);
		}

		render_effect(() => {

			var value = get();

			if (is_numberlike_input(input) && value === to_number(input.value)) {
				// handles 0 vs 00 case (see https://github.com/sveltejs/svelte/issues/9959)
				return;
			}

			if (input.type === 'date' && !value && !input.value) {
				// Handles the case where a temporarily invalid date is set (while typing, for example with a leading 0 for the day)
				// and prevents this state from clearing the other parts of the date input (see https://github.com/sveltejs/svelte/issues/7897)
				return;
			}

			// don't set the value of the input if it's the same to allow
			// minlength to work properly
			if (value !== input.value) {
				// @ts-expect-error the value is coerced on assignment
				input.value = value ?? '';
			}
		});
	}

	/** @type {Set<HTMLInputElement[]>} */
	const pending = new Set();

	/**
	 * @param {HTMLInputElement[]} inputs
	 * @param {null | [number]} group_index
	 * @param {HTMLInputElement} input
	 * @param {() => unknown} get
	 * @param {(value: unknown) => void} set
	 * @returns {void}
	 */
	function bind_group(inputs, group_index, input, get, set = get) {
		var is_checkbox = input.getAttribute('type') === 'checkbox';
		var binding_group = inputs;

		// needs to be let or related code isn't treeshaken out if it's always false
		let hydration_mismatch = false;

		if (group_index !== null) {
			for (var index of group_index) {
				// @ts-expect-error
				binding_group = binding_group[index] ??= [];
			}
		}

		binding_group.push(input);

		listen_to_event_and_reset_event(
			input,
			'change',
			() => {
				// @ts-ignore
				var value = input.__value;

				if (is_checkbox) {
					value = get_binding_group_value(binding_group, value, input.checked);
				}

				set(value);
			},
			// TODO better default value handling
			() => set(is_checkbox ? [] : null)
		);

		render_effect(() => {
			var value = get();

			// If we are hydrating and the value has since changed, then use the update value
			// from the input instead.
			if (hydrating && input.defaultChecked !== input.checked) {
				hydration_mismatch = true;
				return;
			}

			if (is_checkbox) {
				value = value || [];
				// @ts-ignore
				input.checked = value.includes(input.__value);
			} else {
				// @ts-ignore
				input.checked = is(input.__value, value);
			}
		});

		teardown(() => {
			var index = binding_group.indexOf(input);

			if (index !== -1) {
				binding_group.splice(index, 1);
			}
		});

		if (!pending.has(binding_group)) {
			pending.add(binding_group);

			queue_micro_task(() => {
				// necessary to maintain binding group order in all insertion scenarios
				binding_group.sort((a, b) => (a.compareDocumentPosition(b) === 4 ? -1 : 1));
				pending.delete(binding_group);
			});
		}

		queue_micro_task(() => {
			if (hydration_mismatch) {
				var value;

				if (is_checkbox) {
					value = get_binding_group_value(binding_group, value, input.checked);
				} else {
					var hydration_input = binding_group.find((input) => input.checked);
					// @ts-ignore
					value = hydration_input?.__value;
				}

				set(value);
			}
		});
	}

	/**
	 * @param {HTMLInputElement} input
	 * @param {() => unknown} get
	 * @param {(value: unknown) => void} set
	 * @returns {void}
	 */
	function bind_checked(input, get, set = get) {
		listen_to_event_and_reset_event(input, 'change', (is_reset) => {
			var value = is_reset ? input.defaultChecked : input.checked;
			set(value);
		});

		if (
			// If we are hydrating and the value has since changed,
			// then use the update value from the input instead.
			(hydrating && input.defaultChecked !== input.checked) ||
			// If defaultChecked is set, then checked == defaultChecked
			untrack(get) == null
		) {
			set(input.checked);
		}

		render_effect(() => {
			var value = get();
			input.checked = Boolean(value);
		});
	}

	/**
	 * @template V
	 * @param {Array<HTMLInputElement>} group
	 * @param {V} __value
	 * @param {boolean} checked
	 * @returns {V[]}
	 */
	function get_binding_group_value(group, __value, checked) {
		var value = new Set();

		for (var i = 0; i < group.length; i += 1) {
			if (group[i].checked) {
				// @ts-ignore
				value.add(group[i].__value);
			}
		}

		if (!checked) {
			value.delete(__value);
		}

		return Array.from(value);
	}

	/**
	 * @param {HTMLInputElement} input
	 */
	function is_numberlike_input(input) {
		var type = input.type;
		return type === 'number' || type === 'range';
	}

	/**
	 * @param {string} value
	 */
	function to_number(value) {
		return value === '' ? null : +value;
	}

	/**
	 * @param {any} bound_value
	 * @param {Element} element_or_component
	 * @returns {boolean}
	 */
	function is_bound_this(bound_value, element_or_component) {
		return (
			bound_value === element_or_component || bound_value?.[STATE_SYMBOL] === element_or_component
		);
	}

	/**
	 * @param {any} element_or_component
	 * @param {(value: unknown, ...parts: unknown[]) => void} update
	 * @param {(...parts: unknown[]) => unknown} get_value
	 * @param {() => unknown[]} [get_parts] Set if the this binding is used inside an each block,
	 * 										returns all the parts of the each block context that are used in the expression
	 * @returns {void}
	 */
	function bind_this(element_or_component = {}, update, get_value, get_parts) {
		effect(() => {
			/** @type {unknown[]} */
			var old_parts;

			/** @type {unknown[]} */
			var parts;

			render_effect(() => {
				old_parts = parts;
				// We only track changes to the parts, not the value itself to avoid unnecessary reruns.
				parts = [];

				untrack(() => {
					if (element_or_component !== get_value(...parts)) {
						update(element_or_component, ...parts);
						// If this is an effect rerun (cause: each block context changes), then nullfiy the binding at
						// the previous position if it isn't already taken over by a different effect.
						if (old_parts && is_bound_this(get_value(...old_parts), element_or_component)) {
							update(null, ...old_parts);
						}
					}
				});
			});

			return () => {
				// We cannot use effects in the teardown phase, we we use a microtask instead.
				queue_micro_task(() => {
					if (parts && is_bound_this(get_value(...parts), element_or_component)) {
						update(null, ...parts);
					}
				});
			};
		});

		return element_or_component;
	}

	/** @import { ComponentContext, ComponentContextLegacy } from '#client' */
	/** @import { EventDispatcher } from './index.js' */
	/** @import { NotFunction } from './internal/types.js' */

	/**
	 * `onMount`, like [`$effect`](https://svelte.dev/docs/svelte/$effect), schedules a function to run as soon as the component has been mounted to the DOM.
	 * Unlike `$effect`, the provided function only runs once.
	 *
	 * It must be called during the component's initialisation (but doesn't need to live _inside_ the component;
	 * it can be called from an external module). If a function is returned _synchronously_ from `onMount`,
	 * it will be called when the component is unmounted.
	 *
	 * `onMount` functions do not run during [server-side rendering](https://svelte.dev/docs/svelte/svelte-server#render).
	 *
	 * @template T
	 * @param {() => NotFunction<T> | Promise<NotFunction<T>> | (() => any)} fn
	 * @returns {void}
	 */
	function onMount(fn) {
		if (component_context === null) {
			lifecycle_outside_component();
		}

		{
			user_effect(() => {
				const cleanup = untrack(fn);
				if (typeof cleanup === 'function') return /** @type {() => void} */ (cleanup);
			});
		}
	}

	/** @import { StoreReferencesContainer } from '#client' */
	/** @import { Store } from '#shared' */

	/**
	 * Whether or not the prop currently being read is a store binding, as in
	 * `<Child bind:x={$y} />`. If it is, we treat the prop as mutable even in
	 * runes mode, and skip `binding_property_non_reactive` validation
	 */
	let is_store_binding = false;

	/**
	 * Returns a tuple that indicates whether `fn()` reads a prop that is a store binding.
	 * Used to prevent `binding_property_non_reactive` validation false positives and
	 * ensure that these props are treated as mutable even in runes mode
	 * @template T
	 * @param {() => T} fn
	 * @returns {[T, boolean]}
	 */
	function capture_store_binding(fn) {
		var previous_is_store_binding = is_store_binding;

		try {
			is_store_binding = false;
			return [fn(), is_store_binding];
		} finally {
			is_store_binding = previous_is_store_binding;
		}
	}

	/** @import { Derived, Source } from './types.js' */

	/**
	 * The proxy handler for rest props (i.e. `const { x, ...rest } = $props()`).
	 * Is passed the full `$$props` object and excludes the named props.
	 * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, name?: string }>}}
	 */
	const rest_props_handler = {
		get(target, key) {
			if (target.exclude.includes(key)) return;
			return target.props[key];
		},
		set(target, key) {

			return false;
		},
		getOwnPropertyDescriptor(target, key) {
			if (target.exclude.includes(key)) return;
			if (key in target.props) {
				return {
					enumerable: true,
					configurable: true,
					value: target.props[key]
				};
			}
		},
		has(target, key) {
			if (target.exclude.includes(key)) return false;
			return key in target.props;
		},
		ownKeys(target) {
			return Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));
		}
	};

	/**
	 * @param {Record<string, unknown>} props
	 * @param {string[]} exclude
	 * @param {string} [name]
	 * @returns {Record<string, unknown>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function rest_props(props, exclude, name) {
		return new Proxy(
			{ props, exclude },
			rest_props_handler
		);
	}

	/**
	 * The proxy handler for spread props. Handles the incoming array of props
	 * that looks like `() => { dynamic: props }, { static: prop }, ..` and wraps
	 * them so that the whole thing is passed to the component as the `$$props` argument.
	 * @template {Record<string | symbol, unknown>} T
	 * @type {ProxyHandler<{ props: Array<T | (() => T)> }>}}
	 */
	const spread_props_handler = {
		get(target, key) {
			let i = target.props.length;
			while (i--) {
				let p = target.props[i];
				if (is_function(p)) p = p();
				if (typeof p === 'object' && p !== null && key in p) return p[key];
			}
		},
		set(target, key, value) {
			let i = target.props.length;
			while (i--) {
				let p = target.props[i];
				if (is_function(p)) p = p();
				const desc = get_descriptor(p, key);
				if (desc && desc.set) {
					desc.set(value);
					return true;
				}
			}
			return false;
		},
		getOwnPropertyDescriptor(target, key) {
			let i = target.props.length;
			while (i--) {
				let p = target.props[i];
				if (is_function(p)) p = p();
				if (typeof p === 'object' && p !== null && key in p) {
					const descriptor = get_descriptor(p, key);
					if (descriptor && !descriptor.configurable) {
						// Prevent a "Non-configurability Report Error": The target is an array, it does
						// not actually contain this property. If it is now described as non-configurable,
						// the proxy throws a validation error. Setting it to true avoids that.
						descriptor.configurable = true;
					}
					return descriptor;
				}
			}
		},
		has(target, key) {
			// To prevent a false positive `is_entry_props` in the `prop` function
			if (key === STATE_SYMBOL || key === LEGACY_PROPS) return false;

			for (let p of target.props) {
				if (is_function(p)) p = p();
				if (p != null && key in p) return true;
			}

			return false;
		},
		ownKeys(target) {
			/** @type {Array<string | symbol>} */
			const keys = [];

			for (let p of target.props) {
				if (is_function(p)) p = p();
				for (const key in p) {
					if (!keys.includes(key)) keys.push(key);
				}
			}

			return keys;
		}
	};

	/**
	 * @param {Array<Record<string, unknown> | (() => Record<string, unknown>)>} props
	 * @returns {any}
	 */
	function spread_props(...props) {
		return new Proxy({ props }, spread_props_handler);
	}

	/**
	 * @param {Derived} current_value
	 * @returns {boolean}
	 */
	function has_destroyed_component_ctx(current_value) {
		return current_value.ctx?.d ?? false;
	}

	/**
	 * This function is responsible for synchronizing a possibly bound prop with the inner component state.
	 * It is used whenever the compiler sees that the component writes to the prop, or when it has a default prop_value.
	 * @template V
	 * @param {Record<string, unknown>} props
	 * @param {string} key
	 * @param {number} flags
	 * @param {V | (() => V)} [fallback]
	 * @returns {(() => V | ((arg: V) => V) | ((arg: V, mutation: boolean) => V))}
	 */
	function prop(props, key, flags, fallback) {
		var immutable = (flags & PROPS_IS_IMMUTABLE) !== 0;
		var runes = true;
		var bindable = (flags & PROPS_IS_BINDABLE) !== 0;
		var lazy = (flags & PROPS_IS_LAZY_INITIAL) !== 0;
		var is_store_sub = false;
		var prop_value;

		if (bindable) {
			[prop_value, is_store_sub] = capture_store_binding(() => /** @type {V} */ (props[key]));
		} else {
			prop_value = /** @type {V} */ (props[key]);
		}

		// Can be the case when someone does `mount(Component, props)` with `let props = $state({...})`
		// or `createClassComponent(Component, props)`
		var is_entry_props = STATE_SYMBOL in props || LEGACY_PROPS in props;

		var setter =
			(bindable &&
				(get_descriptor(props, key)?.set ??
					(is_entry_props && key in props && ((v) => (props[key] = v))))) ||
			undefined;

		var fallback_value = /** @type {V} */ (fallback);
		var fallback_dirty = true;
		var fallback_used = false;

		var get_fallback = () => {
			fallback_used = true;
			if (fallback_dirty) {
				fallback_dirty = false;
				if (lazy) {
					fallback_value = untrack(/** @type {() => V} */ (fallback));
				} else {
					fallback_value = /** @type {V} */ (fallback);
				}
			}

			return fallback_value;
		};

		if (prop_value === undefined && fallback !== undefined) {
			if (setter && runes) {
				props_invalid_value();
			}

			prop_value = get_fallback();
			if (setter) setter(prop_value);
		}

		/** @type {() => V} */
		var getter;
		{
			getter = () => {
				var value = /** @type {V} */ (props[key]);
				if (value === undefined) return get_fallback();
				fallback_dirty = true;
				fallback_used = false;
				return value;
			};
		}

		// easy mode — prop is never written to
		if ((flags & PROPS_IS_UPDATED) === 0) {
			return getter;
		}

		// intermediate mode — prop is written to, but the parent component had
		// `bind:foo` which means we can just call `$$props.foo = value` directly
		if (setter) {
			var legacy_parent = props.$$legacy;
			return function (/** @type {any} */ value, /** @type {boolean} */ mutation) {
				if (arguments.length > 0) {
					// We don't want to notify if the value was mutated and the parent is in runes mode.
					// In that case the state proxy (if it exists) should take care of the notification.
					// If the parent is not in runes mode, we need to notify on mutation, too, that the prop
					// has changed because the parent will not be able to detect the change otherwise.
					if (!mutation || legacy_parent || is_store_sub) {
						/** @type {Function} */ (setter)(mutation ? getter() : value);
					}
					return value;
				} else {
					return getter();
				}
			};
		}

		// hard mode. this is where it gets ugly — the value in the child should
		// synchronize with the parent, but it should also be possible to temporarily
		// set the value to something else locally.
		var from_child = false;

		// The derived returns the current value. The underlying mutable
		// source is written to from various places to persist this value.
		var inner_current_value = mutable_source(prop_value);
		var current_value = derived(() => {
			var parent_value = getter();
			var child_value = get(inner_current_value);

			if (from_child) {
				from_child = false;
				return child_value;
			}
			return (inner_current_value.v = parent_value);
		});

		// Ensure we eagerly capture the initial value if it's bindable
		if (bindable) {
			get(current_value);
		}

		if (!immutable) current_value.equals = safe_equals;

		return function (/** @type {any} */ value, /** @type {boolean} */ mutation) {

			if (arguments.length > 0) {
				const new_value = mutation ? get(current_value) : bindable ? proxy(value) : value;

				if (!current_value.equals(new_value)) {
					from_child = true;
					set(inner_current_value, new_value);
					// To ensure the fallback value is consistent when used with proxies, we
					// update the local fallback_value, but only if the fallback is actively used
					if (fallback_used && fallback_value !== undefined) {
						fallback_value = new_value;
					}

					if (has_destroyed_component_ctx(current_value)) {
						return value;
					}

					untrack(() => get(current_value)); // force a synchronisation immediately
				}

				return value;
			}

			if (has_destroyed_component_ctx(current_value)) {
				return current_value.v;
			}

			return get(current_value);
		};
	}

	/**
	 * @param {string} binding
	 * @param {() => Record<string, any>} get_object
	 * @param {() => string} get_property
	 * @param {number} line
	 * @param {number} column
	 */
	function validate_binding(binding, get_object, get_property, line, column) {
		var warned = false;

		dev_current_component_function?.[FILENAME];

		render_effect(() => {
			if (warned) return;

			var [object, is_store_sub] = capture_store_binding(get_object);

			if (is_store_sub) return;

			var property = get_property();

			var ran = false;

			// by making the (possibly false, but it would be an extreme edge case) assumption
			// that a getter has a corresponding setter, we can determine if a property is
			// reactive by seeing if this effect has dependencies
			var effect = render_effect(() => {
				if (ran) return;

				// eslint-disable-next-line @typescript-eslint/no-unused-expressions
				object[property];
			});

			ran = true;

			if (effect.deps === null) {
				binding_property_non_reactive();

				warned = true;
			}
		});
	}

	/** @import { ComponentConstructorOptions, ComponentType, SvelteComponent, Component } from 'svelte' */

	/**
	 * Takes the same options as a Svelte 4 component and the component function and returns a Svelte 4 compatible component.
	 *
	 * @deprecated Use this only as a temporary solution to migrate your imperative component code to Svelte 5.
	 *
	 * @template {Record<string, any>} Props
	 * @template {Record<string, any>} Exports
	 * @template {Record<string, any>} Events
	 * @template {Record<string, any>} Slots
	 *
	 * @param {ComponentConstructorOptions<Props> & {
	 * 	component: ComponentType<SvelteComponent<Props, Events, Slots>> | Component<Props>;
	 * }} options
	 * @returns {SvelteComponent<Props, Events, Slots> & Exports}
	 */
	function createClassComponent(options) {
		// @ts-expect-error $$prop_def etc are not actually defined
		return new Svelte4Component(options);
	}

	/**
	 * Support using the component as both a class and function during the transition period
	 * @typedef  {{new (o: ComponentConstructorOptions): SvelteComponent;(...args: Parameters<Component<Record<string, any>>>): ReturnType<Component<Record<string, any>, Record<string, any>>>;}} LegacyComponentType
	 */

	class Svelte4Component {
		/** @type {any} */
		#events;

		/** @type {Record<string, any>} */
		#instance;

		/**
		 * @param {ComponentConstructorOptions & {
		 *  component: any;
		 * }} options
		 */
		constructor(options) {
			var sources = new Map();

			/**
			 * @param {string | symbol} key
			 * @param {unknown} value
			 */
			var add_source = (key, value) => {
				var s = mutable_source(value);
				sources.set(key, s);
				return s;
			};

			// Replicate coarse-grained props through a proxy that has a version source for
			// each property, which is incremented on updates to the property itself. Do not
			// use our $state proxy because that one has fine-grained reactivity.
			const props = new Proxy(
				{ ...(options.props || {}), $$events: {} },
				{
					get(target, prop) {
						return get(sources.get(prop) ?? add_source(prop, Reflect.get(target, prop)));
					},
					has(target, prop) {
						// Necessary to not throw "invalid binding" validation errors on the component side
						if (prop === LEGACY_PROPS) return true;

						get(sources.get(prop) ?? add_source(prop, Reflect.get(target, prop)));
						return Reflect.has(target, prop);
					},
					set(target, prop, value) {
						set(sources.get(prop) ?? add_source(prop, value), value);
						return Reflect.set(target, prop, value);
					}
				}
			);

			this.#instance = (options.hydrate ? hydrate : mount)(options.component, {
				target: options.target,
				anchor: options.anchor,
				props,
				context: options.context,
				intro: options.intro ?? false,
				recover: options.recover
			});

			// We don't flushSync for custom element wrappers or if the user doesn't want it
			if (!options?.props?.$$host || options.sync === false) {
				flushSync();
			}

			this.#events = props.$$events;

			for (const key of Object.keys(this.#instance)) {
				if (key === '$set' || key === '$destroy' || key === '$on') continue;
				define_property(this, key, {
					get() {
						return this.#instance[key];
					},
					/** @param {any} value */
					set(value) {
						this.#instance[key] = value;
					},
					enumerable: true
				});
			}

			this.#instance.$set = /** @param {Record<string, any>} next */ (next) => {
				Object.assign(props, next);
			};

			this.#instance.$destroy = () => {
				unmount(this.#instance);
			};
		}

		/** @param {Record<string, any>} props */
		$set(props) {
			this.#instance.$set(props);
		}

		/**
		 * @param {string} event
		 * @param {(...args: any[]) => any} callback
		 * @returns {any}
		 */
		$on(event, callback) {
			this.#events[event] = this.#events[event] || [];

			/** @param {any[]} args */
			const cb = (...args) => callback.call(this, ...args);
			this.#events[event].push(cb);
			return () => {
				this.#events[event] = this.#events[event].filter(/** @param {any} fn */ (fn) => fn !== cb);
			};
		}

		$destroy() {
			this.#instance.$destroy();
		}
	}

	/**
	 * @typedef {Object} CustomElementPropDefinition
	 * @property {string} [attribute]
	 * @property {boolean} [reflect]
	 * @property {'String'|'Boolean'|'Number'|'Array'|'Object'} [type]
	 */

	/** @type {any} */
	let SvelteElement;

	if (typeof HTMLElement === 'function') {
		SvelteElement = class extends HTMLElement {
			/** The Svelte component constructor */
			$$ctor;
			/** Slots */
			$$s;
			/** @type {any} The Svelte component instance */
			$$c;
			/** Whether or not the custom element is connected */
			$$cn = false;
			/** @type {Record<string, any>} Component props data */
			$$d = {};
			/** `true` if currently in the process of reflecting component props back to attributes */
			$$r = false;
			/** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
			$$p_d = {};
			/** @type {Record<string, EventListenerOrEventListenerObject[]>} Event listeners */
			$$l = {};
			/** @type {Map<EventListenerOrEventListenerObject, Function>} Event listener unsubscribe functions */
			$$l_u = new Map();
			/** @type {any} The managed render effect for reflecting attributes */
			$$me;

			/**
			 * @param {*} $$componentCtor
			 * @param {*} $$slots
			 * @param {*} use_shadow_dom
			 */
			constructor($$componentCtor, $$slots, use_shadow_dom) {
				super();
				this.$$ctor = $$componentCtor;
				this.$$s = $$slots;
				if (use_shadow_dom) {
					this.attachShadow({ mode: 'open' });
				}
			}

			/**
			 * @param {string} type
			 * @param {EventListenerOrEventListenerObject} listener
			 * @param {boolean | AddEventListenerOptions} [options]
			 */
			addEventListener(type, listener, options) {
				// We can't determine upfront if the event is a custom event or not, so we have to
				// listen to both. If someone uses a custom event with the same name as a regular
				// browser event, this fires twice - we can't avoid that.
				this.$$l[type] = this.$$l[type] || [];
				this.$$l[type].push(listener);
				if (this.$$c) {
					const unsub = this.$$c.$on(type, listener);
					this.$$l_u.set(listener, unsub);
				}
				super.addEventListener(type, listener, options);
			}

			/**
			 * @param {string} type
			 * @param {EventListenerOrEventListenerObject} listener
			 * @param {boolean | AddEventListenerOptions} [options]
			 */
			removeEventListener(type, listener, options) {
				super.removeEventListener(type, listener, options);
				if (this.$$c) {
					const unsub = this.$$l_u.get(listener);
					if (unsub) {
						unsub();
						this.$$l_u.delete(listener);
					}
				}
			}

			async connectedCallback() {
				this.$$cn = true;
				if (!this.$$c) {
					// We wait one tick to let possible child slot elements be created/mounted
					await Promise.resolve();
					if (!this.$$cn || this.$$c) {
						return;
					}
					/** @param {string} name */
					function create_slot(name) {
						/**
						 * @param {Element} anchor
						 */
						return (anchor) => {
							const slot = document.createElement('slot');
							if (name !== 'default') slot.name = name;

							append(anchor, slot);
						};
					}
					/** @type {Record<string, any>} */
					const $$slots = {};
					const existing_slots = get_custom_elements_slots(this);
					for (const name of this.$$s) {
						if (name in existing_slots) {
							if (name === 'default' && !this.$$d.children) {
								this.$$d.children = create_slot(name);
								$$slots.default = true;
							} else {
								$$slots[name] = create_slot(name);
							}
						}
					}
					for (const attribute of this.attributes) {
						// this.$$data takes precedence over this.attributes
						const name = this.$$g_p(attribute.name);
						if (!(name in this.$$d)) {
							this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, 'toProp');
						}
					}
					// Port over props that were set programmatically before ce was initialized
					for (const key in this.$$p_d) {
						// @ts-expect-error
						if (!(key in this.$$d) && this[key] !== undefined) {
							// @ts-expect-error
							this.$$d[key] = this[key]; // don't transform, these were set through JavaScript
							// @ts-expect-error
							delete this[key]; // remove the property that shadows the getter/setter
						}
					}
					this.$$c = createClassComponent({
						component: this.$$ctor,
						target: this.shadowRoot || this,
						props: {
							...this.$$d,
							$$slots,
							$$host: this
						}
					});

					// Reflect component props as attributes
					this.$$me = effect_root(() => {
						render_effect(() => {
							this.$$r = true;
							for (const key of object_keys(this.$$c)) {
								if (!this.$$p_d[key]?.reflect) continue;
								this.$$d[key] = this.$$c[key];
								const attribute_value = get_custom_element_value(
									key,
									this.$$d[key],
									this.$$p_d,
									'toAttribute'
								);
								if (attribute_value == null) {
									this.removeAttribute(this.$$p_d[key].attribute || key);
								} else {
									this.setAttribute(this.$$p_d[key].attribute || key, attribute_value);
								}
							}
							this.$$r = false;
						});
					});

					for (const type in this.$$l) {
						for (const listener of this.$$l[type]) {
							const unsub = this.$$c.$on(type, listener);
							this.$$l_u.set(listener, unsub);
						}
					}
					this.$$l = {};
				}
			}

			// We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
			// and setting attributes through setAttribute etc, this is helpful

			/**
			 * @param {string} attr
			 * @param {string} _oldValue
			 * @param {string} newValue
			 */
			attributeChangedCallback(attr, _oldValue, newValue) {
				if (this.$$r) return;
				attr = this.$$g_p(attr);
				this.$$d[attr] = get_custom_element_value(attr, newValue, this.$$p_d, 'toProp');
				this.$$c?.$set({ [attr]: this.$$d[attr] });
			}

			disconnectedCallback() {
				this.$$cn = false;
				// In a microtask, because this could be a move within the DOM
				Promise.resolve().then(() => {
					if (!this.$$cn && this.$$c) {
						this.$$c.$destroy();
						this.$$me();
						this.$$c = undefined;
					}
				});
			}

			/**
			 * @param {string} attribute_name
			 */
			$$g_p(attribute_name) {
				return (
					object_keys(this.$$p_d).find(
						(key) =>
							this.$$p_d[key].attribute === attribute_name ||
							(!this.$$p_d[key].attribute && key.toLowerCase() === attribute_name)
					) || attribute_name
				);
			}
		};
	}

	/**
	 * @param {string} prop
	 * @param {any} value
	 * @param {Record<string, CustomElementPropDefinition>} props_definition
	 * @param {'toAttribute' | 'toProp'} [transform]
	 */
	function get_custom_element_value(prop, value, props_definition, transform) {
		const type = props_definition[prop]?.type;
		value = type === 'Boolean' && typeof value !== 'boolean' ? value != null : value;
		if (!transform || !props_definition[prop]) {
			return value;
		} else if (transform === 'toAttribute') {
			switch (type) {
				case 'Object':
				case 'Array':
					return value == null ? null : JSON.stringify(value);
				case 'Boolean':
					return value ? '' : null;
				case 'Number':
					return value == null ? null : value;
				default:
					return value;
			}
		} else {
			switch (type) {
				case 'Object':
				case 'Array':
					return value && JSON.parse(value);
				case 'Boolean':
					return value; // conversion already handled above
				case 'Number':
					return value != null ? +value : value;
				default:
					return value;
			}
		}
	}

	/**
	 * @param {HTMLElement} element
	 */
	function get_custom_elements_slots(element) {
		/** @type {Record<string, true>} */
		const result = {};
		element.childNodes.forEach((node) => {
			result[/** @type {Element} node */ (node).slot || 'default'] = true;
		});
		return result;
	}

	/**
	 * @internal
	 *
	 * Turn a Svelte component into a custom element.
	 * @param {any} Component  A Svelte component function
	 * @param {Record<string, CustomElementPropDefinition>} props_definition  The props to observe
	 * @param {string[]} slots  The slots to create
	 * @param {string[]} exports  Explicitly exported values, other than props
	 * @param {boolean} use_shadow_dom  Whether to use shadow DOM
	 * @param {(ce: new () => HTMLElement) => new () => HTMLElement} [extend]
	 */
	function create_custom_element(
		Component,
		props_definition,
		slots,
		exports,
		use_shadow_dom,
		extend
	) {
		let Class = class extends SvelteElement {
			constructor() {
				super(Component, slots, use_shadow_dom);
				this.$$p_d = props_definition;
			}
			static get observedAttributes() {
				return object_keys(props_definition).map((key) =>
					(props_definition[key].attribute || key).toLowerCase()
				);
			}
		};
		object_keys(props_definition).forEach((prop) => {
			define_property(Class.prototype, prop, {
				get() {
					return this.$$c && prop in this.$$c ? this.$$c[prop] : this.$$d[prop];
				},
				set(value) {
					value = get_custom_element_value(prop, value, props_definition);
					this.$$d[prop] = value;
					var component = this.$$c;

					if (component) {
						// // If the instance has an accessor, use that instead
						var setter = get_descriptor(component, prop)?.get;

						if (setter) {
							component[prop] = value;
						} else {
							component.$set({ [prop]: value });
						}
					}
				}
			});
		});
		exports.forEach((property) => {
			define_property(Class.prototype, property, {
				get() {
					return this.$$c?.[property];
				}
			});
		});
		if (extend) {
			// @ts-expect-error - assigning here is fine
			Class = extend(Class);
		}
		Component.element = /** @type {any} */ Class;
		return Class;
	}

	class Utils {

	    static assetsBasePath =
	        document
	            .currentScript
	            .getAttribute('sdg-assets-base-path')
	        || new URL(document.currentScript.src).pathname
	                    .split('/')
	                    .slice(0, -2)
	                    .join('/')
	        || '/'
	    static cssRelativePath =
	        `${this.assetsBasePath}/css/`
	            .replace('//','/')
	    static imagesRelativePath =
	        `${this.assetsBasePath}/img/`
	            .replace('//','/')
	    static cssFileName =
	        document
	            .currentScript
	            .getAttribute('sdg-css-filename')
	        || 'qc-sdg.min.css'
	    static cssPath =
	        document
	            .currentScript
	            .getAttribute('sdg-css-path')
	        || this.cssRelativePath + this.cssFileName
	    static sharedTexts =
	        { openInNewTab :
	            { fr: 'Ce lien s’ouvrira dans un nouvel onglet.'
	            , en: 'This link will open in a new tab.'
	            }
	        }

	    /**
	     * Get current page language based on html lang attribute
	     * @returns {string} language code  (fr/en).
	     */
	    static getPageLanguage() {
	        return document.getElementsByTagName("html")[0].getAttribute("lang") || "fr";
	    }

	    static isTruthy(value) {
	        if (typeof value === 'boolean') {
	            return value;
	        }
	        if (typeof value === 'string') {
	            return value.toLowerCase() === 'true' || !!parseInt(value); // Vérifie si la chaîne est "true" (insensible à la casse)
	        }
	        if (typeof value === 'number') {
	            return !!value; // Vérifie si le nombre est égal à 1
	        }
	        return false;
	    }

	    /**
	     * extract and clean prefixed attributes
	     * example:
	     *  computeFieldsAttributes("radio" , {"radio-class":"my-radio", "radio-data-foo":"foo", "other":"other value"})
	     *  return {"class":"my-radio", "data-foo":"foo"}
	     *
	     </div>
	     * @param {(string|string[])} prefix - Une chaîne de caractères ou un tableau de chaînes.
	     * @param restProps - ojbect of attributes
	     * @returns {*} - object of attributes
	     */
	    static computeFieldsAttributes(prefix , restProps) {
	        let output = {},
	            _prefix = prefix + '-';
	        Object
	            .entries(restProps)
	            .forEach(([prop,value]) => {
	                if (prop.startsWith(_prefix)) {
	                    const prefixProp = prop.replace(new RegExp('^' + _prefix), '');
	                    output[prefixProp] = value;
	                }
	            });

	        return output;
	    }

	}

	Icon[FILENAME] = 'src/sdg/components/Icon/Icon.svelte';

	var root$c = add_locations(template(`<div></div>`), Icon[FILENAME], [[15, 0]]);

	function Icon($$anchor, $$props) {
		check_target(new.target);
		push($$props, true);

		let type = prop($$props, 'type', 7),
			label = prop($$props, 'label', 7),
			size = prop($$props, 'size', 7, 'md'),
			color = prop($$props, 'color', 7, 'text-primary'),
			width = prop($$props, 'width', 7, 'auto'),
			height = prop($$props, 'height', 7, 'auto'),
			rest = rest_props(
				$$props,
				[
					'$$slots',
					'$$events',
					'$$legacy',
					'$$host',
					'type',
					'label',
					'size',
					'color',
					'width',
					'height'
				]);

		let attributes = user_derived(() => strict_equals(width(), 'auto') ? { 'data-img-size': size() } : {});
		var div = root$c();
		let attributes_1;

		template_effect(() => attributes_1 = set_attributes(div, attributes_1, {
			role: 'img',
			class: 'qc-icon',
			'aria-label': label(),
			style: `--img-color:var(--qc-color-${color() ?? ''});
            --img-width:${width() ?? ''};
            --img-height:${height() ?? ''};
        `,
			'data-img-type': type(),
			...get(attributes),
			...rest
		}));

		append($$anchor, div);

		return pop({
			get type() {
				return type();
			},
			set type($$value) {
				type($$value);
				flushSync();
			},
			get label() {
				return label();
			},
			set label($$value) {
				label($$value);
				flushSync();
			},
			get size() {
				return size();
			},
			set size($$value = 'md') {
				size($$value);
				flushSync();
			},
			get color() {
				return color();
			},
			set color($$value = 'text-primary') {
				color($$value);
				flushSync();
			},
			get width() {
				return width();
			},
			set width($$value = 'auto') {
				width($$value);
				flushSync();
			},
			get height() {
				return height();
			},
			set height($$value = 'auto') {
				height($$value);
				flushSync();
			},
			...legacy_api()
		});
	}

	create_custom_element(
		Icon,
		{
			type: {},
			label: {},
			size: {},
			color: {},
			width: {},
			height: {}
		},
		[],
		[],
		true
	);

	Notice[FILENAME] = 'src/sdg/components/Notice/Notice.svelte';

	var root$b = add_locations(template(`<div tabindex="0"><div class="icon-container"><div class="qc-icon"><!></div></div> <div class="content-container"><div class="content"><!> <!> <!></div></div></div> <link rel="stylesheet">`, 1), Notice[FILENAME], [
		[
			57,
			0,
			[
				[60, 2, [[61, 4]]],
				[69, 2, [[70, 4]]]
			]
		],
		[83, 0]
	]);

	function Notice($$anchor, $$props) {
		check_target(new.target);
		push($$props, true);

		const isFr = strict_equals(Utils.getPageLanguage(), 'fr');
		const defaultHeader = 'h2';
		const defaultType = 'information';

		const typesDescriptions = {
			'advice': isFr ? "Avis conseil" : "Advisory notice",
			'note': isFr ? "Avis explicatif" : "Explanatory notice",
			'information': isFr ? "Avis général" : "General notice",
			'warning': isFr ? "Avis d’avertissement" : "Warning notice",
			'success': isFr ? "Avis de réussite" : "Success notice",
			'error': isFr ? "Avis d’erreur" : "Error notice"
		};

		let title = prop($$props, 'title', 7, ""),
			type = prop($$props, 'type', 7, defaultType),
			content = prop($$props, 'content', 7, ""),
			header = prop($$props, 'header', 7, defaultHeader),
			icon = prop($$props, 'icon', 7),
			slotContent = prop($$props, 'slotContent', 7);

		const types = Object.keys(typesDescriptions);
		const usedType = types.includes(type()) ? type() : defaultType;
		const usedHeader = header().match(/h[1-6]/) ? header() : defaultHeader;
		const role = strict_equals(usedType, "success") ? "status" : strict_equals(usedType, "error") ? "alert" : null;
		let noticeElement = state(null);

		user_effect(() => {
			if (role && get(noticeElement)) {
				const tempNodes = Array.from(get(noticeElement).childNodes);

				get(noticeElement).innerHTML = "";
				// Réinsère le contenu pour qu'il soit détecté par le lecteur d'écran.
				tempNodes.forEach((node) => get(noticeElement).appendChild(node));
			}
		});

		const shouldUseIcon = strict_equals(usedType, "advice") || strict_equals(usedType, "note");
		// Si le type est "advice" ou "note", on force "neutral" (le gris), sinon on garde le type normal
		const computedType = shouldUseIcon ? "neutral" : usedType;
		const iconType = shouldUseIcon ? icon() ?? "note" : usedType;
		const iconLabel = typesDescriptions[type()] ?? typesDescriptions['information'];
		var fragment = root$b();
		var div = first_child(fragment);

		set_class(div, 1, `qc-component qc-notice qc-${computedType ?? ''}`);

		var div_1 = child(div);
		var div_2 = child(div_1);
		var node_1 = child(div_2);

		Icon(node_1, { type: iconType, label: iconLabel, size: 'nm' });
		reset(div_2);
		reset(div_1);

		var div_3 = sibling(div_1, 2);
		var div_4 = child(div_3);

		set_attribute(div_4, 'role', role);

		var node_2 = child(div_4);

		{
			var consequent = ($$anchor) => {
				var fragment_1 = comment();
				var node_3 = first_child(fragment_1);

				validate_void_dynamic_element(() => usedHeader);
				validate_dynamic_element_tag(() => usedHeader);

				element(
					node_3,
					() => usedHeader,
					false,
					($$element, $$anchor) => {
						var fragment_2 = comment();
						var node_4 = first_child(fragment_2);

						html(node_4, title);
						append($$anchor, fragment_2);
					});

				append($$anchor, fragment_1);
			};

			if_block(node_2, ($$render) => {
				if (title() && strict_equals(title(), "", false)) $$render(consequent);
			});
		}

		var node_5 = sibling(node_2, 2);

		html(node_5, content);

		var node_6 = sibling(node_5, 2);

		snippet(node_6, () => slotContent() ?? noop);
		reset(div_4);
		bind_this(div_4, ($$value) => set(noticeElement, $$value), () => get(noticeElement));
		reset(div_3);
		reset(div);

		var link = sibling(div, 2);

		template_effect(() => set_attribute(link, 'href', Utils.cssPath));
		append($$anchor, fragment);

		return pop({
			get title() {
				return title();
			},
			set title($$value = "") {
				title($$value);
				flushSync();
			},
			get type() {
				return type();
			},
			set type($$value = defaultType) {
				type($$value);
				flushSync();
			},
			get content() {
				return content();
			},
			set content($$value = "") {
				content($$value);
				flushSync();
			},
			get header() {
				return header();
			},
			set header($$value = defaultHeader) {
				header($$value);
				flushSync();
			},
			get icon() {
				return icon();
			},
			set icon($$value) {
				icon($$value);
				flushSync();
			},
			get slotContent() {
				return slotContent();
			},
			set slotContent($$value) {
				slotContent($$value);
				flushSync();
			},
			...legacy_api()
		});
	}

	create_custom_element(
		Notice,
		{
			title: {},
			type: {},
			content: {},
			header: {},
			icon: {},
			slotContent: {}
		},
		[],
		[],
		true
	);

	NoticeWC[FILENAME] = 'src/sdg/components/Notice/NoticeWC.svelte';

	function NoticeWC($$anchor, $$props) {
		check_target(new.target);
		push($$props, true);

		const props = rest_props($$props, ['$$slots', '$$events', '$$legacy', '$$host']);

		{
			const slotContent = wrap_snippet(NoticeWC, function ($$anchor) {
				validate_snippet_args(...arguments);

				var fragment_1 = comment();
				var node = first_child(fragment_1);

				slot(node, $$props, 'default', {}, null);
				append($$anchor, fragment_1);
			});

			Notice($$anchor, spread_props(() => props, { slotContent, $$slots: { slotContent: true } }));
		}

		return pop({ ...legacy_api() });
	}

	customElements.define('qc-notice', create_custom_element(
		NoticeWC,
		{
			title: { attribute: 'title', type: 'String' },
			type: { attribute: 'type', type: 'String' },
			content: { attribute: 'content', type: 'String' },
			header: { attribute: 'header', type: 'String' },
			icon: { attribute: 'icon', type: 'String' }
		},
		['default'],
		[],
		true
	));

	PivHeader[FILENAME] = 'src/sdg/components/PivHeader/PivHeader.svelte';

	var root_1$5 = add_locations(template(`<div class="go-to-content"><a> </a></div>`), PivHeader[FILENAME], [[64, 6, [[65, 8]]]]);
	var root_2$2 = add_locations(template(`<div class="title"><a class="title"> </a></div>`), PivHeader[FILENAME], [[82, 16, [[83, 20]]]]);

	var on_click$1 = (evt, displaySearchForm, focusOnSearchInput) => {
		evt.preventDefault();
		set(displaySearchForm, !get(displaySearchForm));

		tick().then(() => {
			focusOnSearchInput();
		});
	};

	var root_3 = add_locations(template(`<a class="qc-search" href="/" role="button"><span> </span></a>`), PivHeader[FILENAME], [[94, 10, [[105, 12]]]]);
	var root_7 = add_locations(template(`<li><a> </a></li>`), PivHeader[FILENAME], [[117, 32, [[117, 36]]]]);
	var root_8 = add_locations(template(`<li><a> </a></li>`), PivHeader[FILENAME], [[120, 32, [[120, 36]]]]);
	var root_6 = add_locations(template(`<nav><ul><!> <!></ul></nav>`), PivHeader[FILENAME], [[114, 20, [[115, 24]]]]);
	var root_9 = add_locations(template(`<div class="search-zone"><!></div>`), PivHeader[FILENAME], [[132, 10]]);

	var root$a = add_locations(template(`<div role="banner" class="qc-piv-header qc-component"><div><!> <div class="piv-top"><div class="signature-group"><a class="logo" rel="noreferrer"><div role="img"></div></a> <!></div> <div class="right-section"><!> <div class="links"><!></div></div></div> <div class="piv-bottom"><!></div></div></div> <link rel="stylesheet">`, 1), PivHeader[FILENAME], [
		[
			58,
			0,
			[
				[
					62,
					2,
					[
						[
							71,
							4,
							[
								[
									72,
									8,
									[[73, 12, [[78, 16]]]]
								],
								[92, 6, [[108, 8]]]
							]
						],
						[130, 4]
					]
				]
			]
		],
		[141, 0]
	]);

	function PivHeader($$anchor, $$props) {
		check_target(new.target);
		push($$props, true);

		const lang = Utils.getPageLanguage();

		let customElementParent = prop($$props, 'customElementParent', 7),
			logoUrl = prop($$props, 'logoUrl', 7, '/'),
			fullWidth = prop($$props, 'fullWidth', 7, 'false'),
			logoSrc = prop($$props, 'logoSrc', 23, () => Utils.imagesRelativePath + 'QUEBEC_blanc.svg'),
			logoAlt = prop($$props, 'logoAlt', 23, () => strict_equals(lang, 'fr') ? 'Logo du gouvernement du Québec' : 'Logo of government of Québec'),
			titleUrl = prop($$props, 'titleUrl', 7, '/'),
			titleText = prop($$props, 'titleText', 7, ''),
			joinUsText = prop($$props, 'joinUsText', 23, () => strict_equals(lang, 'fr') ? 'Nous joindre' : 'Contact us'),
			joinUsUrl = prop($$props, 'joinUsUrl', 7, ''),
			altLanguageText = prop($$props, 'altLanguageText', 23, () => strict_equals(lang, 'fr') ? 'English' : 'Français'),
			altLanguageUrl = prop($$props, 'altLanguageUrl', 7, ''),
			linksLabel = prop($$props, 'linksLabel', 23, () => strict_equals(lang, 'fr') ? 'Navigation PIV' : 'PIV navigation'),
			goToContent = prop($$props, 'goToContent', 7, 'true'),
			goToContentAnchor = prop($$props, 'goToContentAnchor', 7, '#main'),
			goToContentText = prop($$props, 'goToContentText', 23, () => strict_equals(lang, 'fr') ? 'Passer au contenu' : 'Skip to content'),
			displaySearchText = prop($$props, 'displaySearchText', 23, () => strict_equals(lang, 'fr') ? 'Cliquer pour faire une recherche' : 'Click to search'),
			hideSearchText = prop($$props, 'hideSearchText', 23, () => strict_equals(lang, 'fr') ? 'Masquer la barre de recherche' : 'Hide search bar'),
			enableSearch = prop($$props, 'enableSearch', 7, 'false'),
			showSearch = prop($$props, 'showSearch', 7, 'false'),
			linksSlot = prop($$props, 'linksSlot', 7),
			searchZoneSlot = prop($$props, 'searchZoneSlot', 7),
			slots = prop($$props, 'slots', 7, false);

		let containerClass = state('qc-container'),
			searchZone = state(null),
			displaySearchForm = state(false);

		function focusOnSearchInput() {
			if (get(displaySearchForm)) {
				let input = customElementParent() ? customElementParent().querySelector('[slot="search-zone"] input') : get(searchZone).querySelector('input');

				input?.focus();
			}
		}

		onMount(() => {
			set(containerClass, get(containerClass) + (strict_equals(fullWidth(), 'true') ? '-fluid' : ''));

			if (strict_equals(showSearch(), 'true')) {
				enableSearch('true');
				set(displaySearchForm, true);
			}
		});

		var fragment = root$a();
		var div = first_child(fragment);
		var div_1 = child(div);
		var node = child(div_1);

		{
			var consequent = ($$anchor) => {
				var div_2 = root_1$5();
				var a = child(div_2);
				var text = child(a, true);

				reset(a);
				reset(div_2);

				template_effect(() => {
					set_attribute(a, 'href', goToContentAnchor());
					set_text(text, goToContentText());
				});

				append($$anchor, div_2);
			};

			if_block(node, ($$render) => {
				if (strict_equals(goToContent(), 'true')) $$render(consequent);
			});
		}

		var div_3 = sibling(node, 2);
		var div_4 = child(div_3);
		var a_1 = child(div_4);
		var node_1 = sibling(a_1, 2);

		{
			var consequent_1 = ($$anchor) => {
				var div_5 = root_2$2();
				var a_2 = child(div_5);
				var text_1 = child(a_2, true);

				reset(a_2);
				reset(div_5);

				template_effect(() => {
					set_attribute(a_2, 'href', titleUrl());
					set_text(text_1, titleText());
				});

				append($$anchor, div_5);
			};

			if_block(node_1, ($$render) => {
				if (titleText()) $$render(consequent_1);
			});
		}

		reset(div_4);

		var div_6 = sibling(div_4, 2);
		var node_2 = child(div_6);

		{
			var consequent_2 = ($$anchor) => {
				var a_3 = root_3();

				a_3.__click = [
					on_click$1,
					displaySearchForm,
					focusOnSearchInput
				];

				var span = child(a_3);
				var text_2 = child(span, true);

				reset(span);
				reset(a_3);
				template_effect(() => set_text(text_2, get(displaySearchForm) ? hideSearchText() : displaySearchText()));
				append($$anchor, a_3);
			};

			if_block(node_2, ($$render) => {
				if (Utils.isTruthy(enableSearch())) $$render(consequent_2);
			});
		}

		var div_7 = sibling(node_2, 2);
		var node_3 = child(div_7);

		{
			var consequent_3 = ($$anchor) => {
				var fragment_1 = comment();
				var node_4 = first_child(fragment_1);

				snippet(node_4, linksSlot);
				append($$anchor, fragment_1);
			};

			var alternate = ($$anchor) => {
				var fragment_2 = comment();
				var node_5 = first_child(fragment_2);

				{
					var consequent_6 = ($$anchor) => {
						var nav = root_6();
						var ul = child(nav);
						var node_6 = child(ul);

						{
							var consequent_4 = ($$anchor) => {
								var li = root_7();
								var a_4 = child(li);
								var text_3 = child(a_4, true);

								reset(a_4);
								reset(li);

								template_effect(() => {
									set_attribute(a_4, 'href', altLanguageUrl());
									set_text(text_3, altLanguageText());
								});

								append($$anchor, li);
							};

							if_block(node_6, ($$render) => {
								if (altLanguageUrl()) $$render(consequent_4);
							});
						}

						var node_7 = sibling(node_6, 2);

						{
							var consequent_5 = ($$anchor) => {
								var li_1 = root_8();
								var a_5 = child(li_1);
								var text_4 = child(a_5, true);

								reset(a_5);
								reset(li_1);

								template_effect(() => {
									set_attribute(a_5, 'href', joinUsUrl());
									set_text(text_4, joinUsText());
								});

								append($$anchor, li_1);
							};

							if_block(node_7, ($$render) => {
								if (joinUsUrl()) $$render(consequent_5);
							});
						}

						reset(ul);
						reset(nav);
						template_effect(() => set_attribute(nav, 'aria-label', linksLabel()));
						append($$anchor, nav);
					};

					if_block(node_5, ($$render) => {
						if (joinUsUrl() || altLanguageUrl()) $$render(consequent_6);
					});
				}

				append($$anchor, fragment_2);
			};

			if_block(node_3, ($$render) => {
				if ((!slots() || slots()['links']) && linksSlot()) $$render(consequent_3); else $$render(alternate, false);
			});
		}

		reset(div_7);
		reset(div_6);
		reset(div_3);

		var div_8 = sibling(div_3, 2);
		var node_8 = child(div_8);

		{
			var consequent_8 = ($$anchor) => {
				var div_9 = root_9();
				var node_9 = child(div_9);

				{
					var consequent_7 = ($$anchor) => {
						var fragment_3 = comment();
						var node_10 = first_child(fragment_3);

						snippet(node_10, searchZoneSlot);
						append($$anchor, fragment_3);
					};

					if_block(node_9, ($$render) => {
						if (searchZoneSlot()) $$render(consequent_7);
					});
				}

				reset(div_9);
				bind_this(div_9, ($$value) => set(searchZone, $$value), () => get(searchZone));
				append($$anchor, div_9);
			};

			if_block(node_8, ($$render) => {
				if (get(displaySearchForm)) $$render(consequent_8);
			});
		}

		reset(div_8);
		reset(div_1);
		reset(div);

		var link = sibling(div, 2);

		template_effect(() => {
			set_style(div, `--logo-src:url(${logoSrc() ?? ''})`);
			set_class(div_1, 1, get(containerClass));
			set_attribute(a_1, 'href', logoUrl());
			set_attribute(a_1, 'aria-label', logoAlt());
			set_attribute(link, 'href', Utils.cssPath);
		});

		append($$anchor, fragment);

		return pop({
			get customElementParent() {
				return customElementParent();
			},
			set customElementParent($$value) {
				customElementParent($$value);
				flushSync();
			},
			get logoUrl() {
				return logoUrl();
			},
			set logoUrl($$value = '/') {
				logoUrl($$value);
				flushSync();
			},
			get fullWidth() {
				return fullWidth();
			},
			set fullWidth($$value = 'false') {
				fullWidth($$value);
				flushSync();
			},
			get logoSrc() {
				return logoSrc();
			},
			set logoSrc(
				$$value = Utils.imagesRelativePath + 'QUEBEC_blanc.svg'
			) {
				logoSrc($$value);
				flushSync();
			},
			get logoAlt() {
				return logoAlt();
			},
			set logoAlt(
				$$value = lang === 'fr' ? 'Logo du gouvernement du Québec' : 'Logo of government of Québec'
			) {
				logoAlt($$value);
				flushSync();
			},
			get titleUrl() {
				return titleUrl();
			},
			set titleUrl($$value = '/') {
				titleUrl($$value);
				flushSync();
			},
			get titleText() {
				return titleText();
			},
			set titleText($$value = '') {
				titleText($$value);
				flushSync();
			},
			get joinUsText() {
				return joinUsText();
			},
			set joinUsText(
				$$value = lang === 'fr' ? 'Nous joindre' : 'Contact us'
			) {
				joinUsText($$value);
				flushSync();
			},
			get joinUsUrl() {
				return joinUsUrl();
			},
			set joinUsUrl($$value = '') {
				joinUsUrl($$value);
				flushSync();
			},
			get altLanguageText() {
				return altLanguageText();
			},
			set altLanguageText(
				$$value = lang === 'fr' ? 'English' : 'Français'
			) {
				altLanguageText($$value);
				flushSync();
			},
			get altLanguageUrl() {
				return altLanguageUrl();
			},
			set altLanguageUrl($$value = '') {
				altLanguageUrl($$value);
				flushSync();
			},
			get linksLabel() {
				return linksLabel();
			},
			set linksLabel(
				$$value = lang === 'fr' ? 'Navigation PIV' : 'PIV navigation'
			) {
				linksLabel($$value);
				flushSync();
			},
			get goToContent() {
				return goToContent();
			},
			set goToContent($$value = 'true') {
				goToContent($$value);
				flushSync();
			},
			get goToContentAnchor() {
				return goToContentAnchor();
			},
			set goToContentAnchor($$value = '#main') {
				goToContentAnchor($$value);
				flushSync();
			},
			get goToContentText() {
				return goToContentText();
			},
			set goToContentText(
				$$value = lang === 'fr' ? 'Passer au contenu' : 'Skip to content'
			) {
				goToContentText($$value);
				flushSync();
			},
			get displaySearchText() {
				return displaySearchText();
			},
			set displaySearchText(
				$$value = lang === 'fr' ? 'Cliquer pour faire une recherche' : 'Click to search'
			) {
				displaySearchText($$value);
				flushSync();
			},
			get hideSearchText() {
				return hideSearchText();
			},
			set hideSearchText(
				$$value = lang === 'fr' ? 'Masquer la barre de recherche' : 'Hide search bar'
			) {
				hideSearchText($$value);
				flushSync();
			},
			get enableSearch() {
				return enableSearch();
			},
			set enableSearch($$value = 'false') {
				enableSearch($$value);
				flushSync();
			},
			get showSearch() {
				return showSearch();
			},
			set showSearch($$value = 'false') {
				showSearch($$value);
				flushSync();
			},
			get linksSlot() {
				return linksSlot();
			},
			set linksSlot($$value) {
				linksSlot($$value);
				flushSync();
			},
			get searchZoneSlot() {
				return searchZoneSlot();
			},
			set searchZoneSlot($$value) {
				searchZoneSlot($$value);
				flushSync();
			},
			get slots() {
				return slots();
			},
			set slots($$value = false) {
				slots($$value);
				flushSync();
			},
			...legacy_api()
		});
	}

	delegate(['click']);

	create_custom_element(
		PivHeader,
		{
			customElementParent: {},
			logoUrl: {},
			fullWidth: {},
			logoSrc: {},
			logoAlt: {},
			titleUrl: {},
			titleText: {},
			joinUsText: {},
			joinUsUrl: {},
			altLanguageText: {},
			altLanguageUrl: {},
			linksLabel: {},
			goToContent: {},
			goToContentAnchor: {},
			goToContentText: {},
			displaySearchText: {},
			hideSearchText: {},
			enableSearch: {},
			showSearch: {},
			linksSlot: {},
			searchZoneSlot: {},
			slots: {}
		},
		[],
		[],
		true
	);

	PivHeaderWC[FILENAME] = 'src/sdg/components/PivHeader/PivHeaderWC.svelte';

	function PivHeaderWC($$anchor, $$props) {
		check_target(new.target);

		const $$slots = sanitize_slots($$props);

		push($$props, true);

		let self = prop($$props, 'self', 7),
			props = rest_props(
				$$props,
				[
					'$$slots',
					'$$events',
					'$$legacy',
					'$$host',
					'self'
				]);

		{
			const linksSlot = wrap_snippet(PivHeaderWC, function ($$anchor) {
				validate_snippet_args(...arguments);

				var fragment_1 = comment();
				var node = first_child(fragment_1);

				slot(node, $$props, 'links', {}, null);
				append($$anchor, fragment_1);
			});

			const searchZoneSlot = wrap_snippet(PivHeaderWC, function ($$anchor) {
				validate_snippet_args(...arguments);

				var fragment_2 = comment();
				var node_1 = first_child(fragment_2);

				slot(node_1, $$props, 'search-zone', {}, null);
				append($$anchor, fragment_2);
			});

			PivHeader($$anchor, spread_props(
				{
					get customElementParent() {
						return self();
					}
				},
				() => props,
				{
					slots: $$slots,
					linksSlot,
					searchZoneSlot,
					$$slots: { linksSlot: true, searchZoneSlot: true }
				}
			));
		}

		return pop({
			get self() {
				return self();
			},
			set self($$value) {
				self($$value);
				flushSync();
			},
			...legacy_api()
		});
	}

	customElements.define('qc-piv-header', create_custom_element(
		PivHeaderWC,
		{
			logoUrl: { attribute: 'logo-url' },
			fullWidth: { attribute: 'full-width' },
			logoSrc: { attribute: 'logo-src' },
			logoAlt: { attribute: 'logo-alt' },
			titleUrl: { attribute: 'title-url' },
			titleText: { attribute: 'title-text' },
			linksLabel: { attribute: 'links-label' },
			altLanguageText: { attribute: 'alt-language-text' },
			altLanguageUrl: { attribute: 'alt-language-url' },
			joinUsText: { attribute: 'join-us-text' },
			joinUsUrl: { attribute: 'join-us-url' },
			goToContent: { attribute: 'go-to-content' },
			goToContentAnchor: { attribute: 'go-to-content-anchor' },
			goToContentText: { attribute: 'go-to-content-text' },
			displaySearchText: { attribute: 'display-search-text' },
			hideSearchText: { attribute: 'hide-search-text' },
			enableSearch: { attribute: 'enable-search' },
			showSearch: { attribute: 'show-search' },
			self: {}
		},
		['links', 'search-zone'],
		[],
		true,
		(customElementConstructor) => {
			return class extends customElementConstructor {
				static self;

				constructor() {
					super();
					this.self = this;
				}
			};
		}
	));

	PivFooter[FILENAME] = 'src/sdg/components/PivFooter/PivFooter.svelte';

	var root_2$1 = add_locations(template(`<img>`), PivFooter[FILENAME], [[34, 12]]);
	var root_4$1 = add_locations(template(`<a> </a>`), PivFooter[FILENAME], [[45, 12]]);

	var root$9 = add_locations(template(`<div class="qc-piv-footer qc-container-fluid"><!> <a class="logo"></a> <span class="copyright"><!></span></div> <link rel="stylesheet">`, 1), PivFooter[FILENAME], [
		[20, 0, [[25, 4], [41, 4]]],
		[52, 0]
	]);

	function PivFooter($$anchor, $$props) {
		check_target(new.target);
		push($$props, true);

		const lang = Utils.getPageLanguage();

		let logoUrl = prop($$props, 'logoUrl', 7, '/'),
			logoSrc = prop($$props, 'logoSrc', 23, () => Utils.imagesRelativePath + '/QUEBEC_couleur.svg'),
			logoSrcDarkTheme = prop($$props, 'logoSrcDarkTheme', 23, () => Utils.imagesRelativePath + '/QUEBEC_blanc.svg'),
			logoAlt = prop($$props, 'logoAlt', 23, () => strict_equals(lang, 'fr') ? 'Logo du gouvernement du Québec' : 'Logo of the Quebec government'),
			logoWidth = prop($$props, 'logoWidth', 7, 139),
			logoHeight = prop($$props, 'logoHeight', 7, 50),
			copyrightUrl = prop($$props, 'copyrightUrl', 23, () => strict_equals(lang, 'fr') ? 'https://www.quebec.ca/droit-auteur' : 'https://www.quebec.ca/en/copyright'),
			copyrightText = prop($$props, 'copyrightText', 23, () => '© Gouvernement du Québec, ' + new Date().getFullYear()),
			mainSlot = prop($$props, 'mainSlot', 7),
			copyrightSlot = prop($$props, 'copyrightSlot', 7),
			slots = prop($$props, 'slots', 23, () => ({}));

		var fragment = root$9();
		var div = first_child(fragment);
		var node = child(div);

		{
			var consequent = ($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				snippet(node_1, mainSlot);
				append($$anchor, fragment_1);
			};

			if_block(node, ($$render) => {
				if (mainSlot()) $$render(consequent);
			});
		}

		var a = sibling(node, 2);
		let styles;

		each(
			a,
			21,
			() => [
				['light', logoSrc()],
				['dark', logoSrcDarkTheme()]
			],
			index,
			($$anchor, $$item) => {
				let theme = () => get($$item)[0];

				theme();

				let src = () => get($$item)[1];

				src();

				var img = root_2$1();

				template_effect(() => {
					set_attribute(img, 'src', src());
					set_attribute(img, 'alt', logoAlt());
					set_class(img, 1, `qc-${theme() ?? ''}-theme-show`);
				});

				append($$anchor, img);
			}
		);

		reset(a);

		var span = sibling(a, 2);
		var node_2 = child(span);

		{
			var consequent_1 = ($$anchor) => {
				var fragment_2 = comment();
				var node_3 = first_child(fragment_2);

				snippet(node_3, copyrightSlot);
				append($$anchor, fragment_2);
			};

			var alternate = ($$anchor) => {
				var a_1 = root_4$1();
				var text = child(a_1, true);

				reset(a_1);

				template_effect(() => {
					set_attribute(a_1, 'href', copyrightUrl());
					set_text(text, copyrightText());
				});

				append($$anchor, a_1);
			};

			if_block(node_2, ($$render) => {
				if (!slots() && copyrightSlot() || slots().copyright) $$render(consequent_1); else $$render(alternate, false);
			});
		}

		reset(span);
		reset(div);

		var link = sibling(div, 2);

		template_effect(() => {
			set_attribute(a, 'href', logoUrl());

			styles = set_style(a, '', styles, {
				'--logo-width': logoWidth(),
				'--logo-height': logoHeight()
			});

			set_attribute(link, 'href', Utils.cssPath);
		});

		append($$anchor, fragment);

		return pop({
			get logoUrl() {
				return logoUrl();
			},
			set logoUrl($$value = '/') {
				logoUrl($$value);
				flushSync();
			},
			get logoSrc() {
				return logoSrc();
			},
			set logoSrc(
				$$value = Utils.imagesRelativePath + '/QUEBEC_couleur.svg'
			) {
				logoSrc($$value);
				flushSync();
			},
			get logoSrcDarkTheme() {
				return logoSrcDarkTheme();
			},
			set logoSrcDarkTheme(
				$$value = Utils.imagesRelativePath + '/QUEBEC_blanc.svg'
			) {
				logoSrcDarkTheme($$value);
				flushSync();
			},
			get logoAlt() {
				return logoAlt();
			},
			set logoAlt(
				$$value = lang === 'fr' ? 'Logo du gouvernement du Québec' : 'Logo of the Quebec government'
			) {
				logoAlt($$value);
				flushSync();
			},
			get logoWidth() {
				return logoWidth();
			},
			set logoWidth($$value = 139) {
				logoWidth($$value);
				flushSync();
			},
			get logoHeight() {
				return logoHeight();
			},
			set logoHeight($$value = 50) {
				logoHeight($$value);
				flushSync();
			},
			get copyrightUrl() {
				return copyrightUrl();
			},
			set copyrightUrl(
				$$value = lang === 'fr' ? 'https://www.quebec.ca/droit-auteur' : 'https://www.quebec.ca/en/copyright'
			) {
				copyrightUrl($$value);
				flushSync();
			},
			get copyrightText() {
				return copyrightText();
			},
			set copyrightText(
				$$value = '© Gouvernement du Québec, ' + new Date().getFullYear()
			) {
				copyrightText($$value);
				flushSync();
			},
			get mainSlot() {
				return mainSlot();
			},
			set mainSlot($$value) {
				mainSlot($$value);
				flushSync();
			},
			get copyrightSlot() {
				return copyrightSlot();
			},
			set copyrightSlot($$value) {
				copyrightSlot($$value);
				flushSync();
			},
			get slots() {
				return slots();
			},
			set slots($$value = {}) {
				slots($$value);
				flushSync();
			},
			...legacy_api()
		});
	}

	create_custom_element(
		PivFooter,
		{
			logoUrl: {},
			logoSrc: {},
			logoSrcDarkTheme: {},
			logoAlt: {},
			logoWidth: {},
			logoHeight: {},
			copyrightUrl: {},
			copyrightText: {},
			mainSlot: {},
			copyrightSlot: {},
			slots: {}
		},
		[],
		[],
		true
	);

	PivFooterWC[FILENAME] = 'src/sdg/components/PivFooter/PivFooterWC.svelte';

	function PivFooterWC($$anchor, $$props) {
		check_target(new.target);

		const $$slots = sanitize_slots($$props);

		push($$props, true);

		let self = prop($$props, 'self', 7),
			props = rest_props(
				$$props,
				[
					'$$slots',
					'$$events',
					'$$legacy',
					'$$host',
					'self'
				]);

		{
			const mainSlot = wrap_snippet(PivFooterWC, function ($$anchor) {
				validate_snippet_args(...arguments);

				var fragment_1 = comment();
				var node = first_child(fragment_1);

				slot(node, $$props, 'default', {}, null);
				append($$anchor, fragment_1);
			});

			const copyrightSlot = wrap_snippet(PivFooterWC, function ($$anchor) {
				validate_snippet_args(...arguments);

				var fragment_2 = comment();
				var node_1 = first_child(fragment_2);

				slot(node_1, $$props, 'copyright', {}, null);
				append($$anchor, fragment_2);
			});

			PivFooter($$anchor, spread_props(() => props, {
				slots: $$slots,
				mainSlot,
				copyrightSlot,
				$$slots: { mainSlot: true, copyrightSlot: true }
			}));
		}

		return pop({
			get self() {
				return self();
			},
			set self($$value) {
				self($$value);
				flushSync();
			},
			...legacy_api()
		});
	}

	customElements.define('qc-piv-footer', create_custom_element(
		PivFooterWC,
		{
			logoUrl: { attribute: 'logo-url' },
			logoSrc: { attribute: 'logo-src' },
			logoSrcDarkTheme: { attribute: 'logo-src-dark-theme' },
			logoAlt: { attribute: 'logo-alt' },
			logoWidth: { attribute: 'logo-width' },
			logoHeight: { attribute: 'logo-height' },
			copyrightText: { attribute: 'copyright-text' },
			copyrightUrl: { attribute: 'copyright-url' },
			self: {}
		},
		['default', 'copyright'],
		[],
		true,
		(customElementConstructor) => {
			return class extends customElementConstructor {
				static self;

				constructor() {
					super();
					this.self = this;
				}
			};
		}
	));

	IconButton[FILENAME] = 'src/sdg/components/IconButton/IconButton.svelte';

	var root$8 = add_locations(template(`<button><!></button>`), IconButton[FILENAME], [[16, 0]]);

	function IconButton($$anchor, $$props) {
		check_target(new.target);
		push($$props, true);

		const size = prop($$props, 'size', 7, 'xl'),
			label = prop($$props, 'label', 7),
			icon = prop($$props, 'icon', 7),
			iconSize = prop($$props, 'iconSize', 7),
			iconColor = prop($$props, 'iconColor', 7),
			className = prop($$props, 'class', 7, ''),
			rest = rest_props(
				$$props,
				[
					'$$slots',
					'$$events',
					'$$legacy',
					'$$host',
					'size',
					'label',
					'icon',
					'iconSize',
					'iconColor',
					'class'
				]);

		var button = root$8();
		let attributes;
		var node = child(button);

		{
			var consequent = ($$anchor) => {
				Icon($$anchor, {
					get type() {
						return icon();
					},
					get size() {
						return iconSize();
					},
					get color() {
						return iconColor();
					},
					'aria-hidden': 'true',
					get label() {
						return label();
					}
				});
			};

			if_block(node, ($$render) => {
				if (icon()) $$render(consequent);
			});
		}

		reset(button);

		template_effect(() => attributes = set_attributes(button, attributes, {
			'data-button-size': size(),
			class: `qc-icon-button ${className()}`,
			...rest
		}));

		append($$anchor, button);

		return pop({
			get size() {
				return size();
			},
			set size($$value = 'xl') {
				size($$value);
				flushSync();
			},
			get label() {
				return label();
			},
			set label($$value) {
				label($$value);
				flushSync();
			},
			get icon() {
				return icon();
			},
			set icon($$value) {
				icon($$value);
				flushSync();
			},
			get iconSize() {
				return iconSize();
			},
			set iconSize($$value) {
				iconSize($$value);
				flushSync();
			},
			get iconColor() {
				return iconColor();
			},
			set iconColor($$value) {
				iconColor($$value);
				flushSync();
			},
			get class() {
				return className();
			},
			set class($$value = '') {
				className($$value);
				flushSync();
			},
			...legacy_api()
		});
	}

	create_custom_element(
		IconButton,
		{
			size: {},
			label: {},
			icon: {},
			iconSize: {},
			iconColor: {},
			class: {}
		},
		[],
		[],
		true
	);

	Alert[FILENAME] = 'src/sdg/components/Alert/Alert.svelte';

	var root_1$4 = add_locations(template(`<div role="alert"><div><div class="qc-general-alert-elements"><!> <div class="qc-alert-content"><!> <!></div> <!></div></div></div>`), Alert[FILENAME], [
		[
			40,
			4,
			[
				[
					43,
					8,
					[[44, 12, [[50, 16]]]]
				]
			]
		]
	]);

	var root$7 = add_locations(template(`<!> <link rel="stylesheet">`, 1), Alert[FILENAME], [[68, 0]]);

	function Alert($$anchor, $$props) {
		check_target(new.target);
		push($$props, true);

		let type = prop($$props, 'type', 7, "general"),
			maskable = prop($$props, 'maskable', 7, ""),
			content = prop($$props, 'content', 7, ""),
			hide = prop($$props, 'hide', 7, "false"),
			fullWidth = prop($$props, 'fullWidth', 7, "false"),
			slotContent = prop($$props, 'slotContent', 7);

		const language = Utils.getPageLanguage();
		const typeClass = strict_equals(type(), "", false) ? type() : 'general';
		const closeLabel = strict_equals(language, 'fr') ? "Fermer l’alerte" : "Close l’alerte";
		const warningLabel = strict_equals(language, 'fr') ? "Information d'importance élevée" : "Information of high importance";
		const generalLabel = strict_equals(language, 'fr') ? "Information importante" : "Important information";
		const label = strict_equals(type(), 'general') ? generalLabel : warningLabel;
		let rootElement = state(null);
		let containerClass = "qc-container" + (strict_equals(fullWidth(), 'true') ? '-fluid' : '');

		function hideAlert() {
			hide("true");
			get(rootElement).dispatchEvent(new CustomEvent('qc.alert.hide', { bubbles: true, composed: true }));
		}

		var fragment = root$7();
		var node = first_child(fragment);

		{
			var consequent_1 = ($$anchor) => {
				var div = root_1$4();

				set_class(div, 1, `qc-general-alert ${typeClass ?? ''}`);

				var div_1 = child(div);

				set_class(div_1, 1, clsx(containerClass));

				var div_2 = child(div_1);
				var node_1 = child(div_2);
				const expression = user_derived(() => strict_equals(type(), 'warning') ? 'warning' : 'information');
				const expression_1 = user_derived(() => strict_equals(type(), 'general') ? 'blue-piv' : 'yellow-dark');

				Icon(node_1, {
					get type() {
						return get(expression);
					},
					get color() {
						return get(expression_1);
					},
					size: 'nm',
					label
				});

				var div_3 = sibling(node_1, 2);
				var node_2 = child(div_3);

				html(node_2, content);

				var node_3 = sibling(node_2, 2);

				html(node_3, slotContent);
				reset(div_3);

				var node_4 = sibling(div_3, 2);

				{
					var consequent = ($$anchor) => {
						IconButton($$anchor, {
							'aria-label': closeLabel,
							onclick: hideAlert,
							size: 'nm',
							icon: 'clear-input',
							iconSize: 'sm',
							iconColor: 'text-primary'
						});
					};

					if_block(node_4, ($$render) => {
						if (Utils.isTruthy(maskable())) $$render(consequent);
					});
				}

				reset(div_2);
				reset(div_1);
				reset(div);
				bind_this(div, ($$value) => set(rootElement, $$value), () => get(rootElement));
				append($$anchor, div);
			};

			if_block(node, ($$render) => {
				if (!Utils.isTruthy(hide())) $$render(consequent_1);
			});
		}

		var link = sibling(node, 2);

		template_effect(() => set_attribute(link, 'href', Utils.cssPath));
		append($$anchor, fragment);

		return pop({
			get type() {
				return type();
			},
			set type($$value = "general") {
				type($$value);
				flushSync();
			},
			get maskable() {
				return maskable();
			},
			set maskable($$value = "") {
				maskable($$value);
				flushSync();
			},
			get content() {
				return content();
			},
			set content($$value = "") {
				content($$value);
				flushSync();
			},
			get hide() {
				return hide();
			},
			set hide($$value = "false") {
				hide($$value);
				flushSync();
			},
			get fullWidth() {
				return fullWidth();
			},
			set fullWidth($$value = "false") {
				fullWidth($$value);
				flushSync();
			},
			get slotContent() {
				return slotContent();
			},
			set slotContent($$value) {
				slotContent($$value);
				flushSync();
			},
			...legacy_api()
		});
	}

	create_custom_element(
		Alert,
		{
			type: {},
			maskable: {},
			content: {},
			hide: {},
			fullWidth: {},
			slotContent: {}
		},
		[],
		[],
		true
	);

	AlertWC[FILENAME] = 'src/sdg/components/Alert/AlertWC.svelte';

	function AlertWC($$anchor, $$props) {
		check_target(new.target);
		push($$props, true);

		const props = rest_props($$props, ['$$slots', '$$events', '$$legacy', '$$host']);

		Alert($$anchor, spread_props(() => props, { slotContent: `<slot />` }));
		return pop({ ...legacy_api() });
	}

	customElements.define('qc-alert', create_custom_element(
		AlertWC,
		{
			type: { attribute: 'type' },
			maskable: { attribute: 'maskable' },
			fullWidth: { attribute: 'full-width' },
			content: { attribute: 'content' },
			hide: { attribute: 'hide' }
		},
		[],
		[],
		true
	));

	ToTop[FILENAME] = 'src/sdg/components/ToTop/ToTop.svelte';

	function handleEnterAndSpace(e, scrollToTop) {
		switch (e.code) {
			case 'Enter':

			case 'Space':
				e.preventDefault();
				scrollToTop();
		}
	}

	var on_click = (e, scrollToTop) => scrollToTop(e);
	var root$6 = add_locations(template(`<a href="#top"><!> <span> </span></a>`), ToTop[FILENAME], [[67, 0, [[77, 3]]]]);

	function ToTop($$anchor, $$props) {
		check_target(new.target);
		push($$props, true);

		const lang = Utils.getPageLanguage();

		const text = prop($$props, 'text', 23, () => strict_equals(lang, 'fr') ? "Retour en haut" : "Back to top"),
			demo = prop($$props, 'demo', 7, 'false');

		let visible = state(proxy(strict_equals(demo(), 'true')));
		let lastVisible = setContext('visible', () => get(visible));
		let lastScrollY = 0;
		let minimumScrollHeight = 0;
		let toTopElement;

		function handleScrollUpButton() {
			if (Utils.isTruthy(demo())) {
				return;
			}

			const pageBottom = window.innerHeight + window.scrollY >= document.body.offsetHeight - 1;

			set(visible, lastScrollY > window.scrollY && (document.body.scrollTop > minimumScrollHeight || document.documentElement.scrollTop > minimumScrollHeight) && !pageBottom, true);

			if (!get(visible) && lastVisible) {
				// removing focus on visibility loss
				toTopElement.blur();
			}

			lastVisible = get(visible);
			lastScrollY = window.scrollY;
		}

		function scrollToTop(e) {
			e.preventDefault();
			window.scrollTo({ top: 0, behavior: 'smooth' });
		}

		user_effect(() => {
			lastScrollY = window.scrollY;
		});

		var a = root$6();

		event('scroll', $window, handleScrollUpButton);

		let classes;

		a.__click = [on_click, scrollToTop];
		a.__keydown = [handleEnterAndSpace, scrollToTop];

		var node = child(a);

		Icon(node, { type: 'arrow-up-white', color: 'background' });

		var span = sibling(node, 2);
		var text_1 = child(span, true);

		reset(span);
		reset(a);
		bind_this(a, ($$value) => toTopElement = $$value, () => toTopElement);

		template_effect(
			($0) => {
				classes = set_class(a, 1, 'qc-to-top', null, classes, $0);
				set_attribute(a, 'tabindex', get(visible) ? 0 : -1);
				set_attribute(a, 'demo', demo());
				set_text(text_1, text());
			},
			[() => ({ visible: get(visible) })]
		);

		append($$anchor, a);

		return pop({
			get text() {
				return text();
			},
			set text(
				$$value = lang === 'fr' ? "Retour en haut" : "Back to top"
			) {
				text($$value);
				flushSync();
			},
			get demo() {
				return demo();
			},
			set demo($$value = 'false') {
				demo($$value);
				flushSync();
			},
			...legacy_api()
		});
	}

	delegate(['click', 'keydown']);
	create_custom_element(ToTop, { text: {}, demo: {} }, [], [], true);

	ToTopWC[FILENAME] = 'src/sdg/components/ToTop/toTopWC.svelte';

	function ToTopWC($$anchor, $$props) {
		check_target(new.target);
		push($$props, true);

		const props = rest_props($$props, ['$$slots', '$$events', '$$legacy', '$$host']);

		ToTop($$anchor, spread_props(() => props));
		return pop({ ...legacy_api() });
	}

	customElements.define('qc-to-top', create_custom_element(
		ToTopWC,
		{
			text: { attribute: 'text', type: 'String' },
			demo: { attribute: 'demo', type: 'String' }
		},
		[],
		[],
		false
	));

	ExternalLink[FILENAME] = 'src/sdg/components/ExternalLink/ExternalLink.svelte';

	var root$5 = add_locations(template(`<span role="img" class="qc-ext-link-img"></span>`), ExternalLink[FILENAME], [[89, 0]]);

	function ExternalLink($$anchor, $$props) {
		check_target(new.target);
		push($$props, true);

		const externalIconAlt = prop($$props, 'externalIconAlt', 23, () => strict_equals(Utils.getPageLanguage(), 'fr') ? "Ce lien dirige vers un autre site." : "This link directs to another site.");
		let imgElement = state(void 0);

		function createVisibleNodesTreeWalker() {
			return document.createTreeWalker(get(imgElement).parentElement, NodeFilter.SHOW_ALL, {
				acceptNode: (node) => {
					if (node instanceof Element) {
						if (node.hasAttribute('hidden')) {
							return NodeFilter.FILTER_REJECT;
						}

						const style = window.getComputedStyle(node);

						// Si l'élément est masqué par CSS (display ou visibility), on l'ignore
						if (strict_equals(style.display, 'none') || strict_equals(style.visibility, 'hidden') || strict_equals(style.position, 'absolute')) {
							return NodeFilter.FILTER_REJECT;
						}
					}

					if (!node instanceof Text) {
						return NodeFilter.FILTER_SKIP;
					}

					// Ignore les nœuds vides
					if (!(/\S/).test(node.textContent)) {
						return NodeFilter.FILTER_SKIP;
					}

					return NodeFilter.FILTER_ACCEPT;
				}
			});
		}

		onMount(() => {
			get(imgElement).parentElement.querySelectorAll('a').forEach((link) => {
				// Crée un TreeWalker pour parcourir uniquement les nœuds texte visibles
				const walker = createVisibleNodesTreeWalker();
				let lastTextNode = null;

				while (walker.nextNode()) {
					lastTextNode = walker.currentNode;
				}

				// S'il n'y a pas de nœud texte visible, on ne fait rien
				if (!lastTextNode) {
					return;
				}

				// Séparer le contenu du dernier nœud texte en deux parties :
				// le préfixe (éventuel) et le dernier mot
				const text = lastTextNode.textContent;
				const match = text.match(/^([\s\S]*\s)?(\S+)\s*$/m);

				if (!match) {
					return;
				}

				const prefix = match[1] || "";
				const lastWord = match[2].replace(/([\/\-\u2013\u2014])/g, "$1<wbr>");
				// Crée un span avec white-space: nowrap pour empêcher le saut de ligne de l'image de lien externe
				const span = document.createElement('span');

				span.classList.add('img-wrap');
				span.innerHTML = `${lastWord}`;
				span.appendChild(get(imgElement));

				// Met à jour le nœud texte : on garde le préfixe et on insère le span après
				if (prefix) {
					lastTextNode.textContent = prefix;
					lastTextNode.parentNode.insertBefore(span, lastTextNode.nextSibling);
				} else {
					lastTextNode.parentNode.replaceChild(span, lastTextNode);
				}
			});
		});

		var span_1 = root$5();

		bind_this(span_1, ($$value) => set(imgElement, $$value), () => get(imgElement));
		template_effect(() => set_attribute(span_1, 'aria-label', externalIconAlt()));
		append($$anchor, span_1);

		return pop({
			get externalIconAlt() {
				return externalIconAlt();
			},
			set externalIconAlt(
				$$value = Utils.getPageLanguage() === 'fr' ? "Ce lien dirige vers un autre site." : "This link directs to another site."
			) {
				externalIconAlt($$value);
				flushSync();
			},
			...legacy_api()
		});
	}

	create_custom_element(ExternalLink, { externalIconAlt: {} }, [], [], true);

	ExternalLinkWC[FILENAME] = 'src/sdg/components/ExternalLink/ExternalLinkWC.svelte';

	function ExternalLinkWC($$anchor, $$props) {
		check_target(new.target);
		push($$props, true);

		const props = rest_props($$props, ['$$slots', '$$events', '$$legacy', '$$host']);

		ExternalLink($$anchor, spread_props(() => props));
		return pop({ ...legacy_api() });
	}

	customElements.define('qc-external-link', create_custom_element(ExternalLinkWC, { externalIconAlt: { attribute: 'img-alt' } }, [], [], false));

	SearchInput[FILENAME] = 'src/sdg/components/SearchInput/SearchInput.svelte';

	var root$4 = add_locations(template(`<div class="qc-search-input"><input> <!></div>`), SearchInput[FILENAME], [[18, 0, [[19, 4]]]]);

	function SearchInput($$anchor, $$props) {
		check_target(new.target);
		push($$props, true);

		const lang = Utils.getPageLanguage();

		let value = prop($$props, 'value', 15, ''),
			ariaLabel = prop($$props, 'ariaLabel', 23, () => strict_equals(lang, "fr") ? "Rechercher…" : "Search_"),
			clearAriaLabel = prop($$props, 'clearAriaLabel', 23, () => strict_equals(lang, "fr") ? "Effacer le texte" : "Clear text"),
			rest = rest_props(
				$$props,
				[
					'$$slots',
					'$$events',
					'$$legacy',
					'$$host',
					'value',
					'ariaLabel',
					'clearAriaLabel'
				]);

		let searchInput;
		var div = root$4();
		var input = child(div);

		remove_input_defaults(input);

		let attributes;

		bind_this(input, ($$value) => searchInput = $$value, () => searchInput);

		var node = sibling(input, 2);

		{
			var consequent = ($$anchor) => {
				IconButton($$anchor, {
					type: 'button',
					icon: 'clear-input',
					iconColor: 'blue-piv',
					iconSize: 'sm',
					get 'aria-label'() {
						return clearAriaLabel();
					},
					onclick: (e) => {
						e.preventDefault();
						value("");
						searchInput?.focus();
					}
				});
			};

			if_block(node, ($$render) => {
				if (value()) $$render(consequent);
			});
		}

		reset(div);

		template_effect(() => attributes = set_attributes(input, attributes, {
			type: 'search',
			autocomplete: 'off',
			'aria-label': ariaLabel(),
			...rest
		}));

		bind_value(input, value);
		append($$anchor, div);

		return pop({
			get value() {
				return value();
			},
			set value($$value = '') {
				value($$value);
				flushSync();
			},
			get ariaLabel() {
				return ariaLabel();
			},
			set ariaLabel(
				$$value = lang === "fr" ? "Rechercher…" : "Search_"
			) {
				ariaLabel($$value);
				flushSync();
			},
			get clearAriaLabel() {
				return clearAriaLabel();
			},
			set clearAriaLabel(
				$$value = lang === "fr" ? "Effacer le texte" : "Clear text"
			) {
				clearAriaLabel($$value);
				flushSync();
			},
			...legacy_api()
		});
	}

	create_custom_element(SearchInput, { value: {}, ariaLabel: {}, clearAriaLabel: {} }, [], [], true);

	SearchBar[FILENAME] = 'src/sdg/components/SearchBar/SearchBar.svelte';

	var root$3 = add_locations(template(`<div><!> <!></div>`), SearchBar[FILENAME], [[37, 0]]);

	function SearchBar($$anchor, $$props) {
		check_target(new.target);
		push($$props, true);

		var $$ownership_validator = create_ownership_validator($$props);
		const lang = Utils.getPageLanguage();

		let value = prop($$props, 'value', 15, ''),
			name = prop($$props, 'name', 7, 'q'),
			pivBackground = prop($$props, 'pivBackground', 7, false),
			rest = rest_props(
				$$props,
				[
					'$$slots',
					'$$events',
					'$$legacy',
					'$$host',
					'value',
					'name',
					'pivBackground'
				]);

		let defaultsAttributes = {
			input: {
				"placeholder": strict_equals(lang, "fr") ? "Rechercher…" : "Search",
				"aria-label": strict_equals(lang, "fr") ? "Rechercher…" : "Search"
			},
			submit: {
				"aria-label": strict_equals(lang, "fr") ? "Lancer la recherche" : "Submit search"
			}
		};

		let inputProps = user_derived(() => ({
				...defaultsAttributes.input,
				...Utils.computeFieldsAttributes("input", rest),
				name: name()
			})),
			submitProps = user_derived(() => ({
				...defaultsAttributes.input,
				...Utils.computeFieldsAttributes("submit", rest)
			}));

		var div = root$3();
		let classes;
		var node = child(div);

		{
			$$ownership_validator.binding('value', SearchInput, value);

			SearchInput(node, spread_props(() => get(inputProps), {
				get value() {
					return value();
				},
				set value($$value) {
					value($$value);
				}
			}));
		}

		var node_1 = sibling(node, 2);
		const expression = user_derived(() => pivBackground() ? 'blue-piv' : 'background');

		IconButton(node_1, spread_props(
			{
				type: 'submit',
				get iconColor() {
					return get(expression);
				},
				icon: 'loupe-piv-fine',
				iconSize: 'md'
			},
			() => get(submitProps)
		));

		reset(div);

		template_effect(($0) => classes = set_class(div, 1, 'qc-search-bar', null, classes, $0), [
			() => ({ 'piv-background': pivBackground() })
		]);

		append($$anchor, div);

		return pop({
			get value() {
				return value();
			},
			set value($$value = '') {
				value($$value);
				flushSync();
			},
			get name() {
				return name();
			},
			set name($$value = 'q') {
				name($$value);
				flushSync();
			},
			get pivBackground() {
				return pivBackground();
			},
			set pivBackground($$value = false) {
				pivBackground($$value);
				flushSync();
			},
			...legacy_api()
		});
	}

	create_custom_element(SearchBar, { value: {}, name: {}, pivBackground: {} }, [], [], true);

	SearchBarWC[FILENAME] = 'src/sdg/components/SearchBar/SearchBarWC.svelte';

	function SearchBarWC($$anchor, $$props) {
		check_target(new.target);
		push($$props, true);

		const props = rest_props($$props, ['$$slots', '$$events', '$$legacy', '$$host']);

		SearchBar($$anchor, spread_props(() => props));
		return pop({ ...legacy_api() });
	}

	customElements.define('qc-search-bar', create_custom_element(
		SearchBarWC,
		{
			value: { attribute: 'input-value', type: 'String' },
			name: { attribute: 'input-name', type: 'String' },
			pivBackground: { attribute: 'piv-background', type: 'Boolean' }
		},
		[],
		[],
		false
	));

	SearchInputWC[FILENAME] = 'src/sdg/components/SearchInput/SearchInputWC.svelte';

	function SearchInputWC($$anchor, $$props) {
		check_target(new.target);
		push($$props, true);

		const props = rest_props($$props, ['$$slots', '$$events', '$$legacy', '$$host']);

		SearchInput($$anchor, spread_props(() => props));
		return pop({ ...legacy_api() });
	}

	customElements.define('qc-search-input', create_custom_element(
		SearchInputWC,
		{
			ariaLabel: { attribute: 'aria-label' },
			clearAriaLabel: { attribute: 'clear-aria-label' }
		},
		[],
		[],
		false
	));

	IconWC[FILENAME] = 'src/sdg/components/Icon/IconWC.svelte';

	function IconWC($$anchor, $$props) {
		check_target(new.target);
		push($$props, true);

		const props = rest_props($$props, ['$$slots', '$$events', '$$legacy', '$$host']);

		Icon($$anchor, spread_props(() => props));
		return pop({ ...legacy_api() });
	}

	customElements.define('qc-icon', create_custom_element(
		IconWC,
		{
			type: { attribute: 'icon' },
			label: { attribute: 'label' },
			color: { attribute: 'color' },
			size: { attribute: 'size' },
			width: { attribute: 'width' },
			height: { attribute: 'height' }
		},
		[],
		[],
		false
	));

	IconButtonWC[FILENAME] = 'src/sdg/components/IconButton/IconButtonWC.svelte';

	function IconButtonWC($$anchor, $$props) {
		check_target(new.target);
		push($$props, true);

		const props = rest_props($$props, ['$$slots', '$$events', '$$legacy', '$$host']);

		IconButton($$anchor, spread_props(() => props));
		return pop({ ...legacy_api() });
	}

	customElements.define('qc-icon-button', create_custom_element(
		IconButtonWC,
		{
			size: { attribute: 'size' },
			label: { attribute: 'label' },
			icon: { attribute: 'icon' },
			iconSize: { attribute: 'icon-size' },
			iconColor: { attribute: 'icon-color' }
		},
		[],
		[],
		false
	));

	FormError[FILENAME] = 'src/sdg/components/FormError/FormError.svelte';

	var root_2 = add_locations(template(`<!> <span><!></span>`, 1), FormError[FILENAME], [[18, 8]]);
	var root_1$3 = add_locations(template(`<div class="qc-form-error" role="alert"><!></div>`), FormError[FILENAME], [[7, 0]]);

	function FormError($$anchor, $$props) {
		check_target(new.target);
		push($$props, true);

		let invalid = prop($$props, 'invalid', 7),
			invalidText = prop($$props, 'invalidText', 7);

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var div = root_1$3();
				var node_1 = child(div);

				await_block(node_1, tick, ($$anchor) => {}, ($$anchor) => {
					var fragment_1 = root_2();
					var node_2 = first_child(fragment_1);

					Icon(node_2, {
						type: 'warning',
						color: 'red-regular',
						width: 'var(--error-icon-width)',
						height: 'var(--error-icon-height)'
					});

					var span = sibling(node_2, 2);
					var node_3 = child(span);

					html(node_3, invalidText);
					reset(span);
					append($$anchor, fragment_1);
				});

				reset(div);
				append($$anchor, div);
			};

			if_block(node, ($$render) => {
				if (invalid()) $$render(consequent);
			});
		}

		append($$anchor, fragment);

		return pop({
			get invalid() {
				return invalid();
			},
			set invalid($$value) {
				invalid($$value);
				flushSync();
			},
			get invalidText() {
				return invalidText();
			},
			set invalidText($$value) {
				invalidText($$value);
				flushSync();
			},
			...legacy_api()
		});
	}

	create_custom_element(FormError, { invalid: {}, invalidText: {} }, [], [], true);

	Fieldset[FILENAME] = 'src/sdg/components/Fieldset/Fieldset.svelte';

	var root_1$2 = add_locations(template(`<span class="qc-required" aria-hidden="true">*</span>`), Fieldset[FILENAME], [[39, 12]]);
	var root$2 = add_locations(template(`<fieldset><legend><!> <!></legend> <!> <!></fieldset>`), Fieldset[FILENAME], [[26, 0, [[34, 4]]]]);

	function Fieldset($$anchor, $$props) {
		check_target(new.target);
		push($$props, true);

		const lang = Utils.getPageLanguage();

		let legend = prop($$props, 'legend', 7),
			name = prop($$props, 'name', 7),
			compact = prop($$props, 'compact', 7),
			required = prop($$props, 'required', 7, false),
			disabled = prop($$props, 'disabled', 7),
			invalid = prop($$props, 'invalid', 15, false),
			invalidText = prop($$props, 'invalidText', 23, () => strict_equals(lang, "fr") ? "Champ obligatoire" : "Required field"),
			children = prop($$props, 'children', 7),
			updateValue = prop($$props, 'updateValue', 7, () => {}),
			formFieldElements = prop($$props, 'formFieldElements', 7);

		let legendElement,
			legendId = name() ? "id_" + name() : "legend-" + Math.floor(Math.random() * 1000000);

		onMount(() => {
			legendElement.after(...formFieldElements());
		});

		var fieldset = root$2();

		set_attribute(fieldset, 'aria-describedby', legendId);

		fieldset.__change = function (...$$args) {
			apply(updateValue, this, $$args, Fieldset);
		};

		var legend_1 = child(fieldset);

		set_attribute(legend_1, 'id', legendId);

		var node = child(legend_1);

		html(node, legend);

		var node_1 = sibling(node, 2);

		{
			var consequent = ($$anchor) => {
				var span = root_1$2();

				append($$anchor, span);
			};

			if_block(node_1, ($$render) => {
				if (required()) $$render(consequent);
			});
		}

		reset(legend_1);
		bind_this(legend_1, ($$value) => legendElement = $$value, () => legendElement);

		var node_2 = sibling(legend_1, 2);

		snippet(node_2, () => children() ?? noop);

		var node_3 = sibling(node_2, 2);

		FormError(node_3, {
			get invalid() {
				return invalid();
			},
			get invalidText() {
				return invalidText();
			}
		});

		reset(fieldset);

		template_effect(() => set_class(fieldset, 1, clsx([
			invalid() && "qc-fieldset-invalid",
			"qc-fieldset",
			compact() && "qc-compact",
			disabled() && "qc-disabled"
		])));

		append($$anchor, fieldset);

		return pop({
			get legend() {
				return legend();
			},
			set legend($$value) {
				legend($$value);
				flushSync();
			},
			get name() {
				return name();
			},
			set name($$value) {
				name($$value);
				flushSync();
			},
			get compact() {
				return compact();
			},
			set compact($$value) {
				compact($$value);
				flushSync();
			},
			get required() {
				return required();
			},
			set required($$value = false) {
				required($$value);
				flushSync();
			},
			get disabled() {
				return disabled();
			},
			set disabled($$value) {
				disabled($$value);
				flushSync();
			},
			get invalid() {
				return invalid();
			},
			set invalid($$value = false) {
				invalid($$value);
				flushSync();
			},
			get invalidText() {
				return invalidText();
			},
			set invalidText(
				$$value = lang === "fr" ? "Champ obligatoire" : "Required field"
			) {
				invalidText($$value);
				flushSync();
			},
			get children() {
				return children();
			},
			set children($$value) {
				children($$value);
				flushSync();
			},
			get updateValue() {
				return updateValue();
			},
			set updateValue($$value = () => {}) {
				updateValue($$value);
				flushSync();
			},
			get formFieldElements() {
				return formFieldElements();
			},
			set formFieldElements($$value) {
				formFieldElements($$value);
				flushSync();
			},
			...legacy_api()
		});
	}

	delegate(['change']);

	create_custom_element(
		Fieldset,
		{
			legend: {},
			name: {},
			compact: {},
			required: {},
			disabled: {},
			invalid: {},
			invalidText: {},
			children: {},
			updateValue: {},
			formFieldElements: {}
		},
		[],
		[],
		true
	);

	CheckFieldGroup[FILENAME] = 'src/sdg/components/CheckFieldGroup/CheckFieldGroup.svelte';

	function CheckFieldGroup($$anchor, $$props) {
		check_target(new.target);
		push($$props, true);

		var $$ownership_validator = create_ownership_validator($$props);

		let formFieldElements = prop($$props, 'formFieldElements', 7),
			checked = prop($$props, 'checked', 15, false),
			invalid = prop($$props, 'invalid', 15, false),
			value = prop($$props, 'value', 31, () => proxy([])),
			updateValue = prop($$props, 'updateValue', 7, () => {}),
			restProps = rest_props(
				$$props,
				[
					'$$slots',
					'$$events',
					'$$legacy',
					'$$host',
					'formFieldElements',
					'checked',
					'invalid',
					'value',
					'updateValue'
				]);

		user_effect((_) => {
			// console.log("cb group svelte effect")
			checked(!(!value() || equals$1(value().length, 0)));

			if (checked()) {
				invalid(false);
			}
		});

		{
			$$ownership_validator.binding('value', Fieldset, value);
			$$ownership_validator.binding('checked', Fieldset, checked);
			$$ownership_validator.binding('invalid', Fieldset, invalid);

			Fieldset($$anchor, spread_props(() => restProps, {
				get updateValue() {
					return updateValue();
				},
				get formFieldElements() {
					return formFieldElements();
				},
				get value() {
					return value();
				},
				set value($$value) {
					value($$value);
				},
				get checked() {
					return checked();
				},
				set checked($$value) {
					checked($$value);
				},
				get invalid() {
					return invalid();
				},
				set invalid($$value) {
					invalid($$value);
				}
			}));
		}

		return pop({
			get formFieldElements() {
				return formFieldElements();
			},
			set formFieldElements($$value) {
				formFieldElements($$value);
				flushSync();
			},
			get checked() {
				return checked();
			},
			set checked($$value = false) {
				checked($$value);
				flushSync();
			},
			get invalid() {
				return invalid();
			},
			set invalid($$value = false) {
				invalid($$value);
				flushSync();
			},
			get value() {
				return value();
			},
			set value($$value = []) {
				value($$value);
				flushSync();
			},
			get updateValue() {
				return updateValue();
			},
			set updateValue($$value = () => {}) {
				updateValue($$value);
				flushSync();
			},
			...legacy_api()
		});
	}

	create_custom_element(
		CheckFieldGroup,
		{
			formFieldElements: {},
			checked: {},
			invalid: {},
			value: {},
			updateValue: {}
		},
		[],
		[],
		true
	);

	CheckboxGroupWC[FILENAME] = 'src/sdg/components/CheckFieldGroup/CheckboxGroupWC.svelte';

	function CheckboxGroupWC($$anchor, $$props) {
		check_target(new.target);
		push($$props, true);

		var $$ownership_validator = create_ownership_validator($$props);

		let formFieldElements = prop($$props, 'formFieldElements', 7),
			value = prop($$props, 'value', 31, () => proxy([])),
			checked = prop($$props, 'checked', 15, false),
			legend = prop($$props, 'legend', 7),
			name = prop($$props, 'name', 7),
			compact = prop($$props, 'compact', 7),
			required = prop($$props, 'required', 7),
			disabled = prop($$props, 'disabled', 7),
			invalid = prop($$props, 'invalid', 15, false),
			invalidText = prop($$props, 'invalidText', 7);

		let updateValue = function () {
			value(formFieldElements().map((cb) => cb.checked ? cb.value : false).filter((x) => x));
		};

		{
			$$ownership_validator.binding('value', CheckFieldGroup, value);
			$$ownership_validator.binding('checked', CheckFieldGroup, checked);
			$$ownership_validator.binding('invalid', CheckFieldGroup, invalid);

			CheckFieldGroup($$anchor, {
				get formFieldElements() {
					return formFieldElements();
				},
				get legend() {
					return legend();
				},
				get name() {
					return name();
				},
				get compact() {
					return compact();
				},
				get required() {
					return required();
				},
				get disabled() {
					return disabled();
				},
				get invalidText() {
					return invalidText();
				},
				updateValue,
				get value() {
					return value();
				},
				set value($$value) {
					value($$value);
				},
				get checked() {
					return checked();
				},
				set checked($$value) {
					checked($$value);
				},
				get invalid() {
					return invalid();
				},
				set invalid($$value) {
					invalid($$value);
				}
			});
		}

		return pop({
			get formFieldElements() {
				return formFieldElements();
			},
			set formFieldElements($$value) {
				formFieldElements($$value);
				flushSync();
			},
			get value() {
				return value();
			},
			set value($$value = []) {
				value($$value);
				flushSync();
			},
			get checked() {
				return checked();
			},
			set checked($$value = false) {
				checked($$value);
				flushSync();
			},
			get legend() {
				return legend();
			},
			set legend($$value) {
				legend($$value);
				flushSync();
			},
			get name() {
				return name();
			},
			set name($$value) {
				name($$value);
				flushSync();
			},
			get compact() {
				return compact();
			},
			set compact($$value) {
				compact($$value);
				flushSync();
			},
			get required() {
				return required();
			},
			set required($$value) {
				required($$value);
				flushSync();
			},
			get disabled() {
				return disabled();
			},
			set disabled($$value) {
				disabled($$value);
				flushSync();
			},
			get invalid() {
				return invalid();
			},
			set invalid($$value = false) {
				invalid($$value);
				flushSync();
			},
			get invalidText() {
				return invalidText();
			},
			set invalidText($$value) {
				invalidText($$value);
				flushSync();
			},
			...legacy_api()
		});
	}

	customElements.define('qc-checkbox-group', create_custom_element(
		CheckboxGroupWC,
		{
			compact: { attribute: 'compact', type: 'Boolean' },
			required: { attribute: 'required', type: 'Boolean' },
			disabled: { attribute: 'disabled', type: 'Boolean' },
			invalid: { attribute: 'invalid', type: 'Boolean' },
			invalidText: { attribute: 'invalid-text', type: 'String' },
			formFieldElements: {},
			value: {},
			checked: {},
			legend: {},
			name: {}
		},
		[],
		[],
		false,
		(customElementConstructor) => {
			return class extends customElementConstructor {
				static formFieldElements;

				constructor() {
					super();
					this.formFieldElements = Array.from(this.querySelectorAll('qc-checkbox'));
				}
			};
		}
	));

	Label[FILENAME] = 'src/sdg/components/Label/Label.svelte';

	var root_1$1 = add_locations(template(`<span class="qc-required" aria-hidden="true">*</span>`), Label[FILENAME], [[23, 8]]);
	var root$1 = add_locations(template(`<label><!> <!></label>`), Label[FILENAME], [[12, 0]]);

	function Label($$anchor, $$props) {
		check_target(new.target);
		push($$props, true);

		let forId = prop($$props, 'forId', 7),
			text = prop($$props, 'text', 7),
			required = prop($$props, 'required', 7, false),
			compact = prop($$props, 'compact', 7, false),
			disabled = prop($$props, 'disabled', 7, false),
			bold = prop($$props, 'bold', 7, false);

		var label = root$1();
		var node = child(label);

		html(node, text);

		var node_1 = sibling(node, 2);

		{
			var consequent = ($$anchor) => {
				var span = root_1$1();

				append($$anchor, span);
			};

			if_block(node_1, ($$render) => {
				if (required()) $$render(consequent);
			});
		}

		reset(label);

		template_effect(() => {
			set_attribute(label, 'for', forId());

			set_class(label, 1, clsx([
				"qc-label",
				compact() && "qc-label-compact",
				disabled() && "qc-disabled",
				bold() && "qc-label-bold"
			]));
		});

		append($$anchor, label);

		return pop({
			get forId() {
				return forId();
			},
			set forId($$value) {
				forId($$value);
				flushSync();
			},
			get text() {
				return text();
			},
			set text($$value) {
				text($$value);
				flushSync();
			},
			get required() {
				return required();
			},
			set required($$value = false) {
				required($$value);
				flushSync();
			},
			get compact() {
				return compact();
			},
			set compact($$value = false) {
				compact($$value);
				flushSync();
			},
			get disabled() {
				return disabled();
			},
			set disabled($$value = false) {
				disabled($$value);
				flushSync();
			},
			get bold() {
				return bold();
			},
			set bold($$value = false) {
				bold($$value);
				flushSync();
			},
			...legacy_api()
		});
	}

	create_custom_element(
		Label,
		{
			forId: {},
			text: {},
			required: {},
			compact: {},
			disabled: {},
			bold: {}
		},
		[],
		[],
		true
	);

	Checkbox[FILENAME] = 'src/sdg/components/Checkbox/Checkbox.svelte';

	var root_1 = add_locations(template(`<div><input> <!></div> <!>`, 1), Checkbox[FILENAME], [[35, 4, [[39, 8]]]]);
	var root_4 = add_locations(template(`<div><!></div>`), Checkbox[FILENAME], [[67, 0]]);

	function Checkbox($$anchor, $$props) {
		check_target(new.target);
		push($$props, true);

		const checkboxRow = wrap_snippet(Checkbox, function ($$anchor) {
			validate_snippet_args(...arguments);

			var fragment = root_1();
			var div = first_child(fragment);
			var input = child(div);

			remove_input_defaults(input);

			var event_handler = () => {
				if (checked()) invalid(false);
			};

			let attributes;
			var node = sibling(input, 2);
			const expression = user_derived(() => !parentGroup() && required());

			Label(node, {
				get forId() {
					return get(id);
				},
				get text() {
					return label();
				},
				get required() {
					return get(expression);
				},
				get compact() {
					return compact();
				},
				get disabled() {
					return disabled();
				}
			});

			reset(div);

			var node_1 = sibling(div, 2);

			{
				var consequent = ($$anchor) => {
					FormError($$anchor, {
						get invalid() {
							return invalid();
						},
						get invalidText() {
							return invalidText();
						}
					});
				};

				if_block(node_1, ($$render) => {
					if (!parentGroup()) $$render(consequent);
				});
			}

			template_effect(() => {
				set_class(div, 1, clsx([
					"qc-check-row",
					!parentGroup() && compact() && "qc-compact"
				]));

				attributes = set_attributes(input, attributes, {
					type: 'checkbox',
					value: value(),
					name: name(),
					id: get(id),
					disabled: disabled(),
					'aria-required': required(),
					'aria-invalid': invalid(),
					...rest,
					onchange: event_handler
				});
			});

			bind_checked(input, checked);
			append($$anchor, fragment);
		});

		const lang = Utils.getPageLanguage();

		let value = prop($$props, 'value', 7),
			label = prop($$props, 'label', 7),
			name = prop($$props, 'name', 7),
			disabled = prop($$props, 'disabled', 7, false),
			checked = prop($$props, 'checked', 15, false),
			required = prop($$props, 'required', 7, false),
			compact = prop($$props, 'compact', 7),
			invalid = prop($$props, 'invalid', 15, false),
			invalidText = prop($$props, 'invalidText', 23, () => strict_equals(lang, "fr") ? "Champ obligatoire" : "Required field"),
			parentGroup = prop($$props, 'parentGroup', 7),
			rest = rest_props(
				$$props,
				[
					'$$slots',
					'$$events',
					'$$legacy',
					'$$host',
					'value',
					'label',
					'name',
					'disabled',
					'checked',
					'required',
					'compact',
					'invalid',
					'invalidText',
					'parentGroup'
				]);

		let id = user_derived(() => name() + "_" + value());

		user_effect(() => {
			if (checked()) {
				invalid(false);
			}
		});

		var fragment_2 = comment();
		var node_2 = first_child(fragment_2);

		{
			var consequent_1 = ($$anchor) => {
				checkboxRow($$anchor);
			};

			var alternate = ($$anchor) => {
				var div_1 = root_4();
				var node_3 = child(div_1);

				checkboxRow(node_3);
				reset(div_1);

				template_effect(() => set_class(div_1, 1, clsx([
					"qc-checkbox-single",
					invalid() && "qc-checkbox-single-invalid"
				])));

				append($$anchor, div_1);
			};

			if_block(node_2, ($$render) => {
				if (parentGroup()) $$render(consequent_1); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment_2);

		return pop({
			get value() {
				return value();
			},
			set value($$value) {
				value($$value);
				flushSync();
			},
			get label() {
				return label();
			},
			set label($$value) {
				label($$value);
				flushSync();
			},
			get name() {
				return name();
			},
			set name($$value) {
				name($$value);
				flushSync();
			},
			get disabled() {
				return disabled();
			},
			set disabled($$value = false) {
				disabled($$value);
				flushSync();
			},
			get checked() {
				return checked();
			},
			set checked($$value = false) {
				checked($$value);
				flushSync();
			},
			get required() {
				return required();
			},
			set required($$value = false) {
				required($$value);
				flushSync();
			},
			get compact() {
				return compact();
			},
			set compact($$value) {
				compact($$value);
				flushSync();
			},
			get invalid() {
				return invalid();
			},
			set invalid($$value = false) {
				invalid($$value);
				flushSync();
			},
			get invalidText() {
				return invalidText();
			},
			set invalidText(
				$$value = lang === "fr" ? "Champ obligatoire" : "Required field"
			) {
				invalidText($$value);
				flushSync();
			},
			get parentGroup() {
				return parentGroup();
			},
			set parentGroup($$value) {
				parentGroup($$value);
				flushSync();
			},
			...legacy_api()
		});
	}

	create_custom_element(
		Checkbox,
		{
			value: {},
			label: {},
			name: {},
			disabled: {},
			checked: {},
			required: {},
			compact: {},
			invalid: {},
			invalidText: {},
			parentGroup: {}
		},
		[],
		[],
		true
	);

	CheckboxWC[FILENAME] = 'src/sdg/components/Checkbox/CheckboxWC.svelte';

	function CheckboxWC($$anchor, $$props) {
		check_target(new.target);
		push($$props, true);

		var $$ownership_validator = create_ownership_validator($$props);

		let parentGroup = prop($$props, 'parentGroup', 7),
			value = prop($$props, 'value', 7),
			label = prop($$props, 'label', 7),
			name = prop($$props, 'name', 7),
			disabled = prop($$props, 'disabled', 7),
			checked = prop($$props, 'checked', 15, false),
			required = prop($$props, 'required', 7),
			compact = prop($$props, 'compact', 7),
			invalid = prop($$props, 'invalid', 15, false),
			invalidText = prop($$props, 'invalidText', 7),
			rest = rest_props(
				$$props,
				[
					'$$slots',
					'$$events',
					'$$legacy',
					'$$host',
					'parentGroup',
					'value',
					'label',
					'name',
					'disabled',
					'checked',
					'required',
					'compact',
					'invalid',
					'invalidText'
				]);

		if (parentGroup()) {
			compact(parentGroup().compact);
			invalid(parentGroup().invalid);
			name(parentGroup().name);
		}

		const expression = user_derived(() => label() ?? value());
		const expression_1 = user_derived(() => parentGroup()?.disabled ?? disabled());
		const expression_2 = user_derived(() => parentGroup()?.required ?? required());
		var spread_element = user_derived(() => Utils.computeFieldsAttributes("checkbox", rest));

		{
			$$ownership_validator.binding('checked', Checkbox, checked);
			$$ownership_validator.binding('invalid', Checkbox, invalid);

			Checkbox($$anchor, spread_props(
				{
					get value() {
						return value();
					},
					get label() {
						return get(expression);
					},
					get name() {
						return name();
					},
					get disabled() {
						return get(expression_1);
					},
					get required() {
						return get(expression_2);
					},
					get compact() {
						return compact();
					},
					get invalidText() {
						return invalidText();
					},
					get parentGroup() {
						return parentGroup();
					}
				},
				() => get(spread_element),
				{
					get checked() {
						return checked();
					},
					set checked($$value) {
						checked($$value);
					},
					get invalid() {
						return invalid();
					},
					set invalid($$value) {
						invalid($$value);
					}
				}
			));
		}

		return pop({
			get parentGroup() {
				return parentGroup();
			},
			set parentGroup($$value) {
				parentGroup($$value);
				flushSync();
			},
			get value() {
				return value();
			},
			set value($$value) {
				value($$value);
				flushSync();
			},
			get label() {
				return label();
			},
			set label($$value) {
				label($$value);
				flushSync();
			},
			get name() {
				return name();
			},
			set name($$value) {
				name($$value);
				flushSync();
			},
			get disabled() {
				return disabled();
			},
			set disabled($$value) {
				disabled($$value);
				flushSync();
			},
			get checked() {
				return checked();
			},
			set checked($$value = false) {
				checked($$value);
				flushSync();
			},
			get required() {
				return required();
			},
			set required($$value) {
				required($$value);
				flushSync();
			},
			get compact() {
				return compact();
			},
			set compact($$value) {
				compact($$value);
				flushSync();
			},
			get invalid() {
				return invalid();
			},
			set invalid($$value = false) {
				invalid($$value);
				flushSync();
			},
			get invalidText() {
				return invalidText();
			},
			set invalidText($$value) {
				invalidText($$value);
				flushSync();
			},
			...legacy_api()
		});
	}

	customElements.define('qc-checkbox', create_custom_element(
		CheckboxWC,
		{
			value: { attribute: 'value', type: 'String' },
			label: { attribute: 'label', type: 'String' },
			name: { attribute: 'name', type: 'String' },
			disabled: { attribute: 'disabled', type: 'Boolean' },
			checked: {
				attribute: 'checked',
				reflect: true,
				type: 'Boolean'
			},
			required: { attribute: 'required', type: 'Boolean' },
			compact: { attribute: 'compact', type: 'Boolean' },
			invalid: { attribute: 'invalid', type: 'Boolean' },
			invalidText: { attribute: 'invalid-text', type: 'String' },
			parentGroup: {}
		},
		[],
		[],
		false,
		(customElementConstructor) => {
			return class extends customElementConstructor {
				static parentGroup;

				constructor() {
					super();
					this.parentGroup = this.closest('qc-checkbox-group');
				}
			};
		}
	));

	RadioGroupWC[FILENAME] = 'src/sdg/components/CheckFieldGroup/RadioGroupWC.svelte';

	function RadioGroupWC($$anchor, $$props) {
		check_target(new.target);
		push($$props, true);

		var $$ownership_validator = create_ownership_validator($$props);

		let name = prop($$props, 'name', 7),
			legend = prop($$props, 'legend', 7),
			compact = prop($$props, 'compact', 7),
			formFieldElements = prop($$props, 'formFieldElements', 7),
			required = prop($$props, 'required', 7),
			disabled = prop($$props, 'disabled', 7),
			invalid = prop($$props, 'invalid', 15, false),
			invalidText = prop($$props, 'invalidText', 7),
			value = prop($$props, 'value', 15, ""),
			checked = prop($$props, 'checked', 15, false);

		{
			$$ownership_validator.binding('invalid', CheckFieldGroup, invalid);
			$$ownership_validator.binding('value', CheckFieldGroup, value);
			$$ownership_validator.binding('checked', CheckFieldGroup, checked);

			CheckFieldGroup($$anchor, {
				get name() {
					return name();
				},
				get legend() {
					return legend();
				},
				get compact() {
					return compact();
				},
				get formFieldElements() {
					return formFieldElements();
				},
				get required() {
					return required();
				},
				get disabled() {
					return disabled();
				},
				get invalidText() {
					return invalidText();
				},
				get invalid() {
					return invalid();
				},
				set invalid($$value) {
					invalid($$value);
				},
				get value() {
					return value();
				},
				set value($$value) {
					value($$value);
				},
				get checked() {
					return checked();
				},
				set checked($$value) {
					checked($$value);
				}
			});
		}

		return pop({
			get name() {
				return name();
			},
			set name($$value) {
				name($$value);
				flushSync();
			},
			get legend() {
				return legend();
			},
			set legend($$value) {
				legend($$value);
				flushSync();
			},
			get compact() {
				return compact();
			},
			set compact($$value) {
				compact($$value);
				flushSync();
			},
			get formFieldElements() {
				return formFieldElements();
			},
			set formFieldElements($$value) {
				formFieldElements($$value);
				flushSync();
			},
			get required() {
				return required();
			},
			set required($$value) {
				required($$value);
				flushSync();
			},
			get disabled() {
				return disabled();
			},
			set disabled($$value) {
				disabled($$value);
				flushSync();
			},
			get invalid() {
				return invalid();
			},
			set invalid($$value = false) {
				invalid($$value);
				flushSync();
			},
			get invalidText() {
				return invalidText();
			},
			set invalidText($$value) {
				invalidText($$value);
				flushSync();
			},
			get value() {
				return value();
			},
			set value($$value = "") {
				value($$value);
				flushSync();
			},
			get checked() {
				return checked();
			},
			set checked($$value = false) {
				checked($$value);
				flushSync();
			},
			...legacy_api()
		});
	}

	customElements.define('qc-radio-group', create_custom_element(
		RadioGroupWC,
		{
			name: { attribute: 'name', type: 'String' },
			value: { attribute: 'value', type: 'String' },
			legend: { attribute: 'legend', type: 'String' },
			compact: { attribute: 'compact', type: 'Boolean' },
			required: { attribute: 'required', type: 'Boolean' },
			disabled: { attribute: 'disabled', type: 'Boolean' },
			invalid: { attribute: 'invalid', type: 'Boolean' },
			invalidText: { attribute: 'invalid-text', type: 'String' },
			formFieldElements: {},
			checked: {}
		},
		[],
		[],
		false,
		(customElementConstructor) => {
			return class extends customElementConstructor {
				static formFieldElements;

				constructor() {
					super();
					this.formFieldElements = Array.from(this.querySelectorAll('qc-radio-button'));
				}
			};
		}
	));

	RadioButton[FILENAME] = 'src/sdg/components/RadioButton/RadioButton.svelte';

	var root = add_locations(template(`<div><input> <!></div>`), RadioButton[FILENAME], [[21, 0, [[23, 4]]]]);

	function RadioButton($$anchor, $$props) {
		check_target(new.target);
		push($$props, true);

		const binding_group = [];

		let name = prop($$props, 'name', 7),
			value = prop($$props, 'value', 7),
			label = prop($$props, 'label', 7),
			compact = prop($$props, 'compact', 7),
			checked = prop($$props, 'checked', 7),
			disabled = prop($$props, 'disabled', 7, false),
			required = prop($$props, 'required', 7),
			invalid = prop($$props, 'invalid', 15, false),
			groupValue = prop($$props, 'groupValue', 15),
			rest = rest_props(
				$$props,
				[
					'$$slots',
					'$$events',
					'$$legacy',
					'$$host',
					'name',
					'value',
					'label',
					'compact',
					'checked',
					'disabled',
					'required',
					'invalid',
					'groupValue'
				]);

		var div = root();
		var input = child(div);

		remove_input_defaults(input);

		let attributes;
		var node = sibling(input, 2);
		const expression = user_derived(() => `${name()}_${value()}`);

		Label(node, {
			get forId() {
				return get(expression);
			},
			get text() {
				return label();
			},
			get compact() {
				return compact();
			},
			get disabled() {
				return disabled();
			}
		});

		reset(div);

		template_effect(() => {
			set_class(div, 1, clsx(["qc-check-row", compact() && "qc-compact"]));

			attributes = set_attributes(input, attributes, {
				type: 'radio',
				id: `${name()}_${value()}`,
				name: name(),
				value: value(),
				'aria-required': required(),
				'aria-invalid': invalid(),
				checked: checked(),
				disabled: disabled(),
				...rest
			});
		});

		bind_group(
			binding_group,
			[],
			input,
			() => {
				value();
				return groupValue();
			},
			groupValue
		);

		append($$anchor, div);

		return pop({
			get name() {
				return name();
			},
			set name($$value) {
				name($$value);
				flushSync();
			},
			get value() {
				return value();
			},
			set value($$value) {
				value($$value);
				flushSync();
			},
			get label() {
				return label();
			},
			set label($$value) {
				label($$value);
				flushSync();
			},
			get compact() {
				return compact();
			},
			set compact($$value) {
				compact($$value);
				flushSync();
			},
			get checked() {
				return checked();
			},
			set checked($$value) {
				checked($$value);
				flushSync();
			},
			get disabled() {
				return disabled();
			},
			set disabled($$value = false) {
				disabled($$value);
				flushSync();
			},
			get required() {
				return required();
			},
			set required($$value) {
				required($$value);
				flushSync();
			},
			get invalid() {
				return invalid();
			},
			set invalid($$value = false) {
				invalid($$value);
				flushSync();
			},
			get groupValue() {
				return groupValue();
			},
			set groupValue($$value) {
				groupValue($$value);
				flushSync();
			},
			...legacy_api()
		});
	}

	create_custom_element(
		RadioButton,
		{
			name: {},
			value: {},
			label: {},
			compact: {},
			checked: {},
			disabled: {},
			required: {},
			invalid: {},
			groupValue: {}
		},
		[],
		[],
		true
	);

	RadioButtonWC[FILENAME] = 'src/sdg/components/RadioButton/RadioButtonWC.svelte';

	function RadioButtonWC($$anchor, $$props) {
		check_target(new.target);
		push($$props, true);

		var $$ownership_validator = create_ownership_validator($$props);

		let parent = prop($$props, 'parent', 7),
			name = prop($$props, 'name', 7),
			value = prop($$props, 'value', 7),
			label = prop($$props, 'label', 7),
			checked = prop($$props, 'checked', 15, false),
			disabled = prop($$props, 'disabled', 7),
			invalid = prop($$props, 'invalid', 15, false),
			rest = rest_props(
				$$props,
				[
					'$$slots',
					'$$events',
					'$$legacy',
					'$$host',
					'parent',
					'name',
					'value',
					'label',
					'checked',
					'disabled',
					'invalid'
				]);

		user_effect(() => {
			if (checked()) {
				$$ownership_validator.mutation('parent', ['parent', 'value'], parent().value = value(), 42, 12);
			}
		});

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				validate_binding('bind:groupValue={parent.value}', parent, () => 'value');

				const expression = user_derived(() => disabled() ?? parent().disabled);
				var spread_element = user_derived(() => Utils.computeFieldsAttributes("radio", rest));

				{
					$$ownership_validator.binding('parent', RadioButton, () => parent().value);

					RadioButton($$anchor, spread_props(
						{
							get name() {
								return parent().name;
							},
							get value() {
								return value();
							},
							get label() {
								return label();
							},
							get compact() {
								return parent().compact;
							},
							get checked() {
								return checked();
							},
							get disabled() {
								return get(expression);
							},
							get required() {
								return parent().required;
							},
							get invalid() {
								return parent().invalid;
							}
						},
						() => get(spread_element),
						{
							get groupValue() {
								return parent().value;
							},
							set groupValue($$value) {
								$$ownership_validator.mutation('parent', ['parent', 'value'], parent().value = $$value, 51, 21);
							}
						}
					));
				}
			};

			if_block(node, ($$render) => {
				if (parent()) $$render(consequent);
			});
		}

		append($$anchor, fragment);

		return pop({
			get parent() {
				return parent();
			},
			set parent($$value) {
				parent($$value);
				flushSync();
			},
			get name() {
				return name();
			},
			set name($$value) {
				name($$value);
				flushSync();
			},
			get value() {
				return value();
			},
			set value($$value) {
				value($$value);
				flushSync();
			},
			get label() {
				return label();
			},
			set label($$value) {
				label($$value);
				flushSync();
			},
			get checked() {
				return checked();
			},
			set checked($$value = false) {
				checked($$value);
				flushSync();
			},
			get disabled() {
				return disabled();
			},
			set disabled($$value) {
				disabled($$value);
				flushSync();
			},
			get invalid() {
				return invalid();
			},
			set invalid($$value = false) {
				invalid($$value);
				flushSync();
			},
			...legacy_api()
		});
	}

	customElements.define('qc-radio-button', create_custom_element(
		RadioButtonWC,
		{
			value: { attribute: 'value', type: 'String' },
			label: { attribute: 'label', type: 'String' },
			checked: { attribute: 'checked', type: 'Boolean' },
			disabled: { attribute: 'disabled', type: 'Boolean' },
			parent: {},
			name: {},
			invalid: {}
		},
		[],
		[],
		false,
		(customElementConstructor) => {
			return class extends customElementConstructor {
				static parent;
				static thisElement;

				constructor() {
					super();
					this.thisElement = this;
					this.parent = this.closest('qc-radio-group');
				}
			};
		}
	));

	const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;
	if (isDarkMode) {
	    document.documentElement.classList.add('qc-dark-theme');
	}

})();
